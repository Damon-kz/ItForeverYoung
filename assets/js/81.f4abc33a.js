(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{588:function(t,a,e){"use strict";e.r(a);var r=e(6),i=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"多线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[t._v("#")]),t._v(" 多线程")]),t._v(" "),e("ol",[e("li",[t._v("启动线程的方式有哪些？")]),t._v(" "),e("li",[t._v("run()和start()的区别？")]),t._v(" "),e("li",[t._v("sleep()和wait()的区别？\n"),e("ol",[e("li",[t._v("sleep()是Thread类的静态方法，wait()是Object超类的实例方法；")]),t._v(" "),e("li",[t._v("wait()必须要在sync方法/代码块内被调用，而且需要被notify、notifyAll唤醒；")]),t._v(" "),e("li",[t._v("sleep()会让当前线程进入等待状态，但是不会释放监视器锁，而且超时后自动唤醒；")]),t._v(" "),e("li",[t._v("wait()会让当前线程进入等待状态，并且会释放监视器锁，无论是超时或者被notify、notifyAll方法唤醒后，都需要重新获取监视器锁；")])])]),t._v(" "),e("li",[t._v("interrupt()、interrupted()、isInterrupted()有什么区别\n"),e("ol",[e("li",[t._v("首先要明确一点，线程中断是一个状态值，只有true和false，也就是说，中断一次是true，再中断一次就变成了false；")]),t._v(" "),e("li",[t._v("interrupt()是中断线程的方法，调用一次，线程中断状态变为true，再调用一次，线程中断状态就会变为false；")]),t._v(" "),e("li",[t._v("interrupted()会返回线程的中断状态并且重置线程的中断状态；也就是说，如果线程被中断了，调用interrupted()方法会返回true，并且把线程的中断状态设置为false；")]),t._v(" "),e("li",[t._v("isInterrupted()只会返回线程的中断状态，并不会重置线程的状态状态；也就是说，如果线程被中断了，调用isInterrupted()方法会返回true。")])])]),t._v(" "),e("li",[t._v("join()\n"),e("ol",[e("li",[t._v("调用join方法，实际上还是调用了wait方法，让当前线程进入等待状态；")])])]),t._v(" "),e("li",[t._v("yield()\n"),e("ol",[e("li",[t._v("让当前线程让出CPU执行权，但是，并不代表其他线程就能得到执行权，如果两个线程优先级一样，可能当前线程刚让出执行权，紧接着又获取到了执行权；")]),t._v(" "),e("li",[t._v("所以，yield方法只是一个建议，有点类似于，当前线程快执行完了，或者已经执行完了，那就可以调用yield方法建议CPU可以调度其他线程了。")])])])]),t._v(" "),e("h2",{attrs:{id:"关键字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关键字"}},[t._v("#")]),t._v(" 关键字")]),t._v(" "),e("h3",{attrs:{id:"static"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#static"}},[t._v("#")]),t._v(" static")]),t._v(" "),e("h3",{attrs:{id:"final"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#final"}},[t._v("#")]),t._v(" final")]),t._v(" "),e("h3",{attrs:{id:"transient"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#transient"}},[t._v("#")]),t._v(" transient")]),t._v(" "),e("p",[t._v("被transient修饰的属性不会被序列化。")]),t._v(" "),e("h3",{attrs:{id:"volatile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[t._v("#")]),t._v(" "),e("RouterLink",{attrs:{to:"/java/volatile.html"}},[t._v("volatile")])],1),t._v(" "),e("h2",{attrs:{id:"其他"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[t._v("#")]),t._v(" 其他")]),t._v(" "),e("h3",{attrs:{id:"jdk-中的排序算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jdk-中的排序算法"}},[t._v("#")]),t._v(" "),e("RouterLink",{attrs:{to:"/java/jdk-sort.html"}},[t._v("jdk 中的排序算法")])],1),t._v(" "),e("h3",{attrs:{id:"jni-java-native-interface-java本地接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jni-java-native-interface-java本地接口"}},[t._v("#")]),t._v(" JNI(Java native interface，Java本地接口)")])])}),[],!1,null,null,null);a.default=i.exports}}]);