(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{587:function(v,_,t){"use strict";t.r(_);var l=t(6),a=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"io-篇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#io-篇"}},[v._v("#")]),v._v(" IO 篇")]),v._v(" "),t("h2",{attrs:{id:"面试问题连环炮"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试问题连环炮"}},[v._v("#")]),v._v(" 面试问题连环炮")]),v._v(" "),t("ol",[t("li",[v._v("什么是IO？")]),v._v(" "),t("li",[v._v("BIO、NIO、AIO 有什么区别？")]),v._v(" "),t("li",[v._v("Netty了解吗？")])]),v._v(" "),t("h2",{attrs:{id:"分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分析"}},[v._v("#")]),v._v(" 分析")]),v._v(" "),t("p",[v._v("首先，解释下同步/异步和阻塞/非阻塞的概念，")]),v._v(" "),t("ul",[t("li",[v._v("同步，是指由用户线程主动从内核空间copy数据")]),v._v(" "),t("li",[v._v("异步，是指由内核空间主动copy数据到用户空间")]),v._v(" "),t("li",[v._v("阻塞，是指当内核空间没有数据返回时，用户线程要阻塞在调用处，直到数据返回")]),v._v(" "),t("li",[v._v("非阻塞，是指用户线程在请求数据后，可以立即返回，不用阻塞在调用处")])]),v._v(" "),t("p",[v._v("然后，下面就可以大致分析下四种IO模型，")]),v._v(" "),t("ul",[t("li",[v._v("同步阻塞IO，由用户线程发起读取数据的请求，并且用户线程会一直阻塞在调用处，直到内核空间有数据后，开始读取")]),v._v(" "),t("li",[v._v("同步非阻塞IO，由用户线程发起请求，如果此时内核空间还没有数据到达，则用户线程可以先返回处理其他逻辑，期间用户线程可以调用方法查看内核空间是否有数据了，如果数据到达，则开始读取")]),v._v(" "),t("li",[v._v("IO多路复用，和同步非阻塞IO比较类似，区别是，IO多路复用不需要每个用户线程去查看内核空间的数据是否到达，而是有一个专门的线程去查看多个用户线程的数据状态，如果有数据到达，该线程会通知目标线程去读取数据")]),v._v(" "),t("li",[v._v("异步非阻塞IO，用户线程发起读取数据的请求后，直接返回，并注册一个回调到内核空间，当数据到达后，会由内核空间主动copy到用户空间，copy完成后，会调通知到用户线程")])]),v._v(" "),t("p",[v._v("根据上面的分析，可以很清楚的发现，")]),v._v(" "),t("ul",[t("li",[v._v("BIO，其实就对应了同步阻塞IO")]),v._v(" "),t("li",[v._v("NIO，对应了IO多路复用")]),v._v(" "),t("li",[v._v("AIO，对应了异步非阻塞IO")])]),v._v(" "),t("p",[v._v("那么，Netty又是什么呢？")])])}),[],!1,null,null,null);_.default=a.exports}}]);