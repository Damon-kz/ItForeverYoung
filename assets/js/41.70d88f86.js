(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{396:function(a,t,s){"use strict";s.r(t);var r=s(43),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"高并发系统设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高并发系统设计"}},[a._v("#")]),a._v(" 高并发系统设计")]),a._v(" "),s("h2",{attrs:{id:"设计一个秒杀系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计一个秒杀系统"}},[a._v("#")]),a._v(" 设计一个秒杀系统")]),a._v(" "),s("h3",{attrs:{id:"需要考虑的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#需要考虑的问题"}},[a._v("#")]),a._v(" 需要考虑的问题")]),a._v(" "),s("ol",[s("li",[a._v("防止超卖")]),a._v(" "),s("li",[a._v("避免缓存出现宕机")]),a._v(" "),s("li",[a._v("服务降级，限流，熔断")])]),a._v(" "),s("h3",{attrs:{id:"解决思路"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决思路"}},[a._v("#")]),a._v(" 解决思路")]),a._v(" "),s("ol",[s("li",[a._v("首先考虑单一原则，我们专门设计一个秒杀系统，使用单独的数据库，这样的话，即便秒杀系统挂了，也不会影响其他服务。")]),a._v(" "),s("li",[a._v("秒杀系统集群部署，既然单机服务怕挂掉，那我就多部署几个服务，前端可以通过Nginx进行负载均衡。")]),a._v(" "),s("li",[a._v("Redis也进行集群部署，主从模式/Sentinel 哨兵模式/cluster 集群模式")]),a._v(" "),s("li",[a._v("缓存预热，把相关的商品信息，秒杀数量等等全都加载到缓存中，尽量保证在秒杀阶段这些信息都能命中缓存。")]),a._v(" "),s("li",[a._v("静态资源加载到cdn中，尽量减少前端服务的压力。")]),a._v(" "),s("li",[a._v("对请求URL进行加密，避免有人直接通过查看服务端URL写脚本发送大量请求。")]),a._v(" "),s("li",[a._v("在前端页面做限流，间隔100ms（配置）之内的重复点击，不发送请求。")]),a._v(" "),s("li",[a._v("在网关层做限流，同一个ip地址的请求超过10次（配置）后即不做处理，避免有人通过查看url直接把请求打到服务端。")]),a._v(" "),s("li",[a._v("在service层，先抢库存，写一个lua脚本，有库存时就-1返回true，没库存时就返回false。")]),a._v(" "),s("li",[a._v("当service层返回false时，前端可以直接提示用户秒杀失败，这样就避免了用户的无效点击（对用户来说无效，但是对系统来说可是实打实的一次请求，所以此处也是限流）。")]),a._v(" "),s("li",[a._v("当某个请求抢库存成功之后，将创建订单的动作组装一个message发布到mq中，订单系统从mq中接受message开始真正的创建订单。")]),a._v(" "),s("li",[a._v("创建订单完成后，可以异步发送消息提示用户，秒杀成功。")]),a._v(" "),s("li",[s("s",[a._v("如果有多种商品秒杀，上述第9步也有可能发生单点故障，毕竟Redis的qps也是有上限的，即便是我们做了集群部署。那么此时可以考虑，把减库存、创建订单两个动作组装成一个message发布到mq中，然后异步处理。")])]),a._v(" "),s("li",[a._v("服务降级其实就是考虑到资源不够用的问题，由于此时我们主要考虑秒杀系统，所以可以把用户管理、地址管理等等服务降级。")]),a._v(" "),s("li",[a._v("上述设计中，步骤7，8，9，10其实都属于限流操作。")]),a._v(" "),s("li",[a._v("上述设计中，其实没有具体的熔断措施，但是，因为一开始，就把秒杀系统做成了一个独立的系统，并且与其他系统的交互都是通过mq，所以即便是秒杀系统宕机，也不会影响其他服务。")])]),a._v(" "),s("p",[s("strong",[a._v("注：考虑到Redis的访问速度很快，一般的秒杀可以参考思路9、10，如果是商品很多的秒杀活动，可以把步骤9、10更换为步骤11。")])]),a._v(" "),s("h2",{attrs:{id:"分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[a._v("#")]),a._v(" 分布式锁")]),a._v(" "),s("h3",{attrs:{id:"zookeeper-实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper-实现"}},[a._v("#")]),a._v(" zookeeper 实现")]),a._v(" "),s("h3",{attrs:{id:"redis-实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-实现"}},[a._v("#")]),a._v(" Redis 实现")]),a._v(" "),s("h3",{attrs:{id:"mysql-实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql-实现"}},[a._v("#")]),a._v(" MySQL 实现")]),a._v(" "),s("h2",{attrs:{id:"分布式事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[a._v("#")]),a._v(" 分布式事务")]),a._v(" "),s("h3",{attrs:{id:"tcc（两阶段提交协议）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcc（两阶段提交协议）"}},[a._v("#")]),a._v(" tcc（两阶段提交协议）")]),a._v(" "),s("h3",{attrs:{id:"最大努力保证模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最大努力保证模式"}},[a._v("#")]),a._v(" 最大努力保证模式")]),a._v(" "),s("h3",{attrs:{id:"事务补偿机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务补偿机制"}},[a._v("#")]),a._v(" 事务补偿机制")]),a._v(" "),s("h2",{attrs:{id:"了解哪些限流方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#了解哪些限流方案"}},[a._v("#")]),a._v(" 了解哪些限流方案")]),a._v(" "),s("h2",{attrs:{id:"如何实现一个熔断器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何实现一个熔断器"}},[a._v("#")]),a._v(" 如何实现一个熔断器")])])}),[],!1,null,null,null);t.default=e.exports}}]);