<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ReentrantReadWriteLock | IT Forever Young</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="IT Forever Young">
    <link rel="preload" href="/assets/css/0.styles.148e837a.css" as="style"><link rel="preload" href="/assets/js/app.7059aeb2.js" as="script"><link rel="preload" href="/assets/js/2.d76243a0.js" as="script"><link rel="preload" href="/assets/js/48.94d48ed5.js" as="script"><link rel="prefetch" href="/assets/js/10.d36e4ea1.js"><link rel="prefetch" href="/assets/js/11.cfdf0cba.js"><link rel="prefetch" href="/assets/js/12.08540bcc.js"><link rel="prefetch" href="/assets/js/13.f5b401ec.js"><link rel="prefetch" href="/assets/js/14.90863b8c.js"><link rel="prefetch" href="/assets/js/15.0f0bd45d.js"><link rel="prefetch" href="/assets/js/16.8fd45856.js"><link rel="prefetch" href="/assets/js/17.fcab2e21.js"><link rel="prefetch" href="/assets/js/18.53c8ce42.js"><link rel="prefetch" href="/assets/js/19.29cc7480.js"><link rel="prefetch" href="/assets/js/20.42d8e602.js"><link rel="prefetch" href="/assets/js/21.b4e94e62.js"><link rel="prefetch" href="/assets/js/22.46118059.js"><link rel="prefetch" href="/assets/js/23.2c88b5e3.js"><link rel="prefetch" href="/assets/js/24.b06b63b3.js"><link rel="prefetch" href="/assets/js/25.282bfa12.js"><link rel="prefetch" href="/assets/js/26.1e5436df.js"><link rel="prefetch" href="/assets/js/27.79f4771d.js"><link rel="prefetch" href="/assets/js/28.ac38ffa0.js"><link rel="prefetch" href="/assets/js/29.6e096544.js"><link rel="prefetch" href="/assets/js/3.febe60f5.js"><link rel="prefetch" href="/assets/js/30.b6c257db.js"><link rel="prefetch" href="/assets/js/31.ca2d66be.js"><link rel="prefetch" href="/assets/js/32.ff10ffd9.js"><link rel="prefetch" href="/assets/js/33.7bdc4532.js"><link rel="prefetch" href="/assets/js/34.1af36f13.js"><link rel="prefetch" href="/assets/js/35.8fb97262.js"><link rel="prefetch" href="/assets/js/36.8156f964.js"><link rel="prefetch" href="/assets/js/37.3ba4c663.js"><link rel="prefetch" href="/assets/js/38.6e05f666.js"><link rel="prefetch" href="/assets/js/39.f0e3e0d5.js"><link rel="prefetch" href="/assets/js/4.140739cc.js"><link rel="prefetch" href="/assets/js/40.06066751.js"><link rel="prefetch" href="/assets/js/41.808923d9.js"><link rel="prefetch" href="/assets/js/42.61aebca9.js"><link rel="prefetch" href="/assets/js/43.a18aca93.js"><link rel="prefetch" href="/assets/js/44.360b0dc8.js"><link rel="prefetch" href="/assets/js/45.ecfaf6b1.js"><link rel="prefetch" href="/assets/js/46.34af45f8.js"><link rel="prefetch" href="/assets/js/47.7ce7671c.js"><link rel="prefetch" href="/assets/js/49.a6fc282b.js"><link rel="prefetch" href="/assets/js/5.58daf8e4.js"><link rel="prefetch" href="/assets/js/50.7475e576.js"><link rel="prefetch" href="/assets/js/51.e86ea7cd.js"><link rel="prefetch" href="/assets/js/52.bf1cdd51.js"><link rel="prefetch" href="/assets/js/53.67539f65.js"><link rel="prefetch" href="/assets/js/54.5c035391.js"><link rel="prefetch" href="/assets/js/55.85b2e749.js"><link rel="prefetch" href="/assets/js/56.1d13e57f.js"><link rel="prefetch" href="/assets/js/57.24004aaf.js"><link rel="prefetch" href="/assets/js/58.b4d07cf4.js"><link rel="prefetch" href="/assets/js/59.1358209e.js"><link rel="prefetch" href="/assets/js/6.04ed65ff.js"><link rel="prefetch" href="/assets/js/60.a16086dc.js"><link rel="prefetch" href="/assets/js/61.d9eb502c.js"><link rel="prefetch" href="/assets/js/62.5d3024fc.js"><link rel="prefetch" href="/assets/js/63.1791b5f6.js"><link rel="prefetch" href="/assets/js/64.4f3dfeff.js"><link rel="prefetch" href="/assets/js/65.914e864b.js"><link rel="prefetch" href="/assets/js/66.ad0d221d.js"><link rel="prefetch" href="/assets/js/67.d2cfc0fd.js"><link rel="prefetch" href="/assets/js/68.d6c8fae4.js"><link rel="prefetch" href="/assets/js/69.eaded2e1.js"><link rel="prefetch" href="/assets/js/7.2b72e1bd.js"><link rel="prefetch" href="/assets/js/70.334b8d0e.js"><link rel="prefetch" href="/assets/js/71.11257e79.js"><link rel="prefetch" href="/assets/js/72.f1501b81.js"><link rel="prefetch" href="/assets/js/73.ba0b0330.js"><link rel="prefetch" href="/assets/js/74.417ce953.js"><link rel="prefetch" href="/assets/js/75.60fa51e7.js"><link rel="prefetch" href="/assets/js/76.d1c0f46b.js"><link rel="prefetch" href="/assets/js/77.2bdffd7c.js"><link rel="prefetch" href="/assets/js/78.d701dbea.js"><link rel="prefetch" href="/assets/js/79.1c4809ca.js"><link rel="prefetch" href="/assets/js/8.e947dc13.js"><link rel="prefetch" href="/assets/js/80.359ee954.js"><link rel="prefetch" href="/assets/js/81.17d8b235.js"><link rel="prefetch" href="/assets/js/82.86bf37c7.js"><link rel="prefetch" href="/assets/js/83.4f434059.js"><link rel="prefetch" href="/assets/js/84.32d0e319.js"><link rel="prefetch" href="/assets/js/85.cec51a81.js"><link rel="prefetch" href="/assets/js/86.55fcc957.js"><link rel="prefetch" href="/assets/js/87.a5a5b8d3.js"><link rel="prefetch" href="/assets/js/88.0c4a55d0.js"><link rel="prefetch" href="/assets/js/89.d29d0483.js"><link rel="prefetch" href="/assets/js/9.5ef6d551.js"><link rel="prefetch" href="/assets/js/90.c8e46c34.js"><link rel="prefetch" href="/assets/js/91.12ecae0b.js"><link rel="prefetch" href="/assets/js/92.26cd4eec.js"><link rel="prefetch" href="/assets/js/93.3325f73b.js"><link rel="prefetch" href="/assets/js/94.b8931972.js"><link rel="prefetch" href="/assets/js/95.8c322137.js"><link rel="prefetch" href="/assets/js/96.1d888ef8.js"><link rel="prefetch" href="/assets/js/97.15a72f24.js"><link rel="prefetch" href="/assets/js/98.c648cf76.js">
    <link rel="stylesheet" href="/assets/css/0.styles.148e837a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">IT Forever Young</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/interview/" class="nav-link">
  面试专题
</a></div> <a href="https://github.com/itForeverYoung/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/interview/" class="nav-link">
  面试专题
</a></div> <a href="https://github.com/itForeverYoung/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/collection.html" class="sidebar-link">Java 集合</a></li><li><a href="/java/queue.html" class="sidebar-link">Java 队列/栈</a></li><li><a href="/java/hashmap.html" class="sidebar-link">HashMap</a></li><li><a href="/java/concurrent-hashmap.html" class="sidebar-link">ConcurrentHashMap</a></li><li><a href="/java/proxy.html" class="sidebar-link">Java 代理</a></li><li><a href="/java/lock.html" class="sidebar-link">Java 锁</a></li><li><a href="/java/juc.html" class="sidebar-link">JUC 并发编程包</a></li><li><a href="/java/aqs.html" class="sidebar-link">AbstractQueuedSynchronizer</a></li><li><a href="/java/ReentrantLock.html" class="sidebar-link">ReentrantLock</a></li><li><a href="/java/ReentrantReadWriteLock.html" aria-current="page" class="active sidebar-link">ReentrantReadWriteLock</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/ReentrantReadWriteLock.html#问题" class="sidebar-link">问题</a></li><li class="sidebar-sub-header"><a href="/java/ReentrantReadWriteLock.html#源码分析" class="sidebar-link">源码分析</a></li><li class="sidebar-sub-header"><a href="/java/ReentrantReadWriteLock.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/java/StampedLock.html" class="sidebar-link">StampedLock</a></li><li><a href="/java/CountDownLatch.html" class="sidebar-link">CountDownLatch</a></li><li><a href="/java/CyclicBarrier.html" class="sidebar-link">CyclicBarrier</a></li><li><a href="/java/Semaphore.html" class="sidebar-link">Semaphore</a></li><li><a href="/java/atomic.html" class="sidebar-link">Atomic* 类</a></li><li><a href="/java/thread-pool-executor.html" class="sidebar-link">ThreadPoolExecutor</a></li><li><a href="/java/thread-local.html" class="sidebar-link">ThreadLocal</a></li><li><a href="/java/jdk-sort.html" class="sidebar-link">jdk 中的排序算法</a></li><li><a href="/java/synchronized.html" class="sidebar-link">synchronized 关键字</a></li><li><a href="/java/volatile.html" class="sidebar-link">volatile 关键字</a></li><li><a href="/java/jmm.html" class="sidebar-link">JMM</a></li><li><a href="/java/jvm.html" class="sidebar-link">JVM</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="reentrantreadwritelock"><a href="#reentrantreadwritelock" class="header-anchor">#</a> ReentrantReadWriteLock</h1> <p><strong>可重入读写锁</strong></p> <h2 id="问题"><a href="#问题" class="header-anchor">#</a> 问题</h2> <h2 id="源码分析"><a href="#源码分析" class="header-anchor">#</a> 源码分析</h2> <p><strong>ReentrantReadWriteLock比ReentrantLock要复杂的多的多，建议先看一下<a href="/java/ReentrantLock.html">ReentrantLock</a>的分析，做好心里准备吧。</strong></p> <p>先明确几个名词，在本文中，</p> <ol><li>读锁 == 共享锁</li> <li>写锁 == 独占锁</li> <li>重入次数 == 加锁次数</li></ol> <p>首先，ReentrantReadWriteLock和ReentrantLock一样，分别定义了Sync、FairSync、NoFairSync三个内部类，下面直接看源码进行分析。</p> <h3 id="sync"><a href="#sync" class="header-anchor">#</a> Sync</h3> <p>和ReentrantLock.Sync一样，ReentrantReadWriteLock的Sync类也继承<a href="/java/aqs.html">AQS</a>类。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 首先要明确，Sync通过把父类的state属性拆分，高16位表示读锁的count，低16位表示写锁的count</span>
<span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">6317671515068378041L</span><span class="token punctuation">;</span>
  	<span class="token comment">// 共享锁移位的值，16位</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHARED_SHIFT   <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token comment">// 共享锁单元，</span>
    <span class="token comment">// 共享锁每重入一次，则需要将state+SHARED_UNIT，</span>
    <span class="token comment">// 共享锁每释放一次，则需要将state-SHARED_UNIT，</span>
    <span class="token comment">/** 举例，
     * 当state=0时，二进制表示为：00000000 00000000 00000000 00000000
     * 如果此时要加一个读锁，是不是要把二进制的第16位变成1，也就是：00000000 00000001 00000000 00000000
     * 那如何让00000000 00000000 00000000 00000000 -&gt; 00000000 00000001 00000000 00000000
     * 是不是只要进行下面的操作就可以了。
     * 00000000 00000000 00000000 00000000 + 00000000 00000001 00000000 00000000
     * 而 (1 &lt;&lt; 16) == 00000000 00000001 00000000 00000000
     * 仔细品品。
     */</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHARED_UNIT    <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> SHARED_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 两种锁的最大可重入次数，也就是2^16-1</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_COUNT      <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> SHARED_SHIFT<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 独占锁的掩码，其实就是定义了一个高16位全都为0，低16位全为1的int变量。</span>
    <span class="token comment">// 下面计算独占锁的重入次数时，通过与运算，得到state的低16位的值</span>
    <span class="token comment">// 00000000 00000000 11111111 11111111</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXCLUSIVE_MASK <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> SHARED_SHIFT<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">/** Returns the number of shared holds represented in count  */</span>
    <span class="token comment">// 将c无符号右移16位，高位补0，得到state的高16位的值，也就是读锁的重入次数</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&gt;&gt;&gt;</span> SHARED_SHIFT<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">/** Returns the number of exclusive holds represented in count  */</span>
    <span class="token comment">// 将c和上面定义的独占锁掩码进行与运算，得到state的低16位的值，也就是写锁的重入次数</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> EXCLUSIVE_MASK<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// sync内部类，定义了一个count计数器来保存每个线程自己持有的读锁的重入次数</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HoldCounter</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">// Use id, not reference, to avoid garbage retention</span>
        <span class="token keyword">final</span> <span class="token keyword">long</span> tid <span class="token operator">=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 继承了ThreadLocal，代表是线程间独立的</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalHoldCounter</span>
        <span class="token keyword">extends</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HoldCounter</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">HoldCounter</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HoldCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 保存当前线程持有的读锁的重入次数</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">ThreadLocalHoldCounter</span> readHolds<span class="token punctuation">;</span>
    <span class="token comment">// </span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HoldCounter</span> cachedHoldCounter<span class="token punctuation">;</span>
    <span class="token comment">// 第一个加读锁的线程</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Thread</span> firstReader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 第一个加读锁的线程的重入次数</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> firstReaderHoldCount<span class="token punctuation">;</span>
    <span class="token comment">// 默认构造方法，初始化了线程间独立的readHolds变量</span>
    <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        readHolds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalHoldCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ensures visibility of readHolds</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 加读锁时要不要阻塞，交给子类实现</span>
    <span class="token keyword">abstract</span> <span class="token keyword">boolean</span> <span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 加写锁时要不要阻塞，交给子类实现</span>
    <span class="token keyword">abstract</span> <span class="token keyword">boolean</span> <span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 独占锁释放</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      	<span class="token comment">// 如果当前线程不是持有写锁的线程，那么直接抛出异常</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token comment">// 到这里，可以知道，的确是当前线程持有写锁</span>
      	<span class="token comment">// 然后，将当前的同步属性state的值-releases，一般情况下，releases=1</span>
        <span class="token keyword">int</span> nextc <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>
      	<span class="token comment">// 这里做了一次判断，如果发现nextc的低16位的值为0，那就说明当前写锁全部释放了</span>
        <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>free<span class="token punctuation">)</span>
          	<span class="token comment">// 就需要把当前持有独占锁的变量设置为null</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token comment">// 将nextc的值赋值给同步属性state</span>
        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 这里又两种情况</span>
      	<span class="token comment">// 1. 返回true，写锁全部释放，当前已经没有写锁了</span>
      	<span class="token comment">// 2. 返回false，本次写锁释放成功，但是当前线程还持有额外的写锁。注：因为写锁是可重入锁</span>
        <span class="token keyword">return</span> free<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 独占锁加锁</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*
         * Walkthrough:
         * 1. If read count nonzero or write count nonzero
         *    and owner is a different thread, fail.
         * 2. If count would saturate, fail. (This can only
         *    happen if count is already nonzero.)
         * 3. Otherwise, this thread is eligible for lock if
         *    it is either a reentrant acquire or
         *    queue policy allows it. If so, update state
         *    and set owner.
         */</span>
        <span class="token comment">/*
         * tryAcquire方法的执行逻辑如下，
         * 1. 如果是下面两种情况，则，加锁失败；
         * 1.1. 读锁数量不为0，读写互斥，返回false
         * 1.2. 写锁数量不为0，但并不是当前线程持有写锁，写写互斥，返回false
         * 2. 如果判断写锁数量已经达到上限，则，加锁失败；
         * 3. 如果是下面两种情况，则，加写锁；
         * 3.1. 当前先是重入获取写锁，代表线程已经持有了写锁，那就直接修改同步属性state的值
         * 3.2. 当前线程加写锁不需要阻塞，那就调用cas方法更新同步属性state的值
         * 3.2.1. 如果当前线程加写锁需要阻塞，返回false
         * 3.2.2. 如果cas加锁失败，返回false
         * 3.2.3. 如果cas加锁成功，则设置当前线程为持有独占锁的线程
         */</span>
        <span class="token comment">// 得到当前线程</span>
        <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取当前同步属性state的值</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取当前的写锁的数量</span>
        <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果c != 0，代表当前有线程持有锁</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span>
            <span class="token comment">// 这里对应两种情况</span>
            <span class="token comment">// 1. 写锁数量为0，代表有线程持有读锁，读写互斥，加锁失败，返回false</span>
            <span class="token comment">// 2. 写锁数量不为0，代表有线程持有写锁，那么，</span>
            <span class="token comment">// 2.1. 如果当前线程不是持有写锁的线程，写写互斥，加锁失败，返回false</span>
            <span class="token comment">// 2.2. 如果当前线程是持有写锁的线程，代码继续向下执行</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> current <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果w+exclusiveCount(acquires)大于最大写锁数量，则抛出一个错误</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">+</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span> <span class="token operator">&gt;</span> MAX_COUNT<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// Reentrant acquire</span>
            <span class="token comment">// 由于当前线程已经持有了写锁，写锁是独占锁，</span>
            <span class="token comment">// 所以调用setState()方法不会冲突，这里就直接更新了同步属性state的值</span>
            <span class="token function">setState</span><span class="token punctuation">(</span>c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 加锁成功，返回true</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 代码执行到这里，代表c == 0，即现在是无锁状态，那么，</span>
        <span class="token comment">// 如果，1. 当前加写锁需要阻塞；2. cas更新同步属性state失败，加锁失败，返回false</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>
            <span class="token operator">!</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">// 代码执行到这里，代表加锁成功，那么就把当前线程设置为持有独占锁的线程</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 加锁成功，返回true</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 共享锁释放</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      	<span class="token comment">// 拿到当前线程</span>
        <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          	<span class="token comment">// 如果当前线程是第一个加读锁的线程</span>
          	<span class="token comment">// 1. 当前线程只持有一个读锁了，那就把firstReader置空</span>
          	<span class="token comment">// 2. 否则，firstReaderHoldCount--，代表释放了1次读锁</span>
            <span class="token comment">// assert firstReaderHoldCount &gt; 0;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReaderHoldCount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
                firstReader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                firstReaderHoldCount<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          	<span class="token comment">// 如果当前线程不是第一个加读锁的线程</span>
          	<span class="token comment">// 1. 从threadLocal中拿到当前线程持有的读锁重入计数器，如果拿不到就初始化一个</span>
          	<span class="token comment">// 		1.1. 这里需要注意，正常情况下，rh肯定不为空，因为在申请加锁的时候已经初始化过了</span>
          	<span class="token comment">// 		1.2. 如果rh=null，说明现在调用者的代码有问题，在没有加过读锁的情况下去释放读锁</span>
            <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
                rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> count <span class="token operator">=</span> rh<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              	<span class="token comment">// count &lt;= 1，代表当前线程至多持有一个读锁，也可能没有，即count == 0</span>
              	<span class="token comment">// 移除当前线程持有的threadLocal的引用</span>
                readHolds<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              	<span class="token comment">// 如果count == 0，那就得抛出异常了，因为这不是正常的加解锁。</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token keyword">throw</span> <span class="token function">unmatchedUnlockException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
          	<span class="token comment">// 然后count-1</span>
            <span class="token operator">--</span>rh<span class="token punctuation">.</span>count<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      	<span class="token comment">// 代码执行到这里，代表当前线程肯定已经释放了一次读锁，所以AQS类的同步属性state的高16位需要-1</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          	<span class="token comment">// 外层是个死循环，代表这里更新同步属性state必须成功</span>
            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          	<span class="token comment">// 将state - SHARED_UNIT赋值给nextc，</span>
          	<span class="token comment">// 然后一直循环调用compareAndSetState()方法去更新同步属性state，直到更新成功</span>
            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">-</span> SHARED_UNIT<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// Releasing the read lock has no effect on readers,</span>
                <span class="token comment">// but it may allow waiting writers to proceed if</span>
                <span class="token comment">// both read and write locks are now free.</span>
              	<span class="token comment">// 更新state成功后，代码执行到这里，为什么是判断nextc == 0呢，仔细思考下</span>
              	<span class="token comment">// 由于读写互斥，而当前方法又是释放读锁的方法，这说明，</span>
              	<span class="token comment">// 1. 现在没有线程持有写锁，即state的低16位 == 0，那么，</span>
              	<span class="token comment">// 		1.1. 如果nextc == 0，返回true，代表当前读写锁全部释放了，已经没有无锁了</span>
              	<span class="token comment">// 		1.2. 如果nextc != 0，返回false，代表只是本次读锁释放成功了</span>
              	<span class="token comment">// 2. 当前线程持有写锁，state的低16位 != 0，那么，</span>
              	<span class="token comment">// 		2.1. nextc != 0，返回false，代表只是本次读锁释放成功了</span>
                <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 定义了一个默认的异常，当有线程去释放读锁，但是它又没持有读锁，会抛出</span>
    <span class="token keyword">private</span> <span class="token class-name">IllegalMonitorStateException</span> <span class="token function">unmatchedUnlockException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span>
            <span class="token string">&quot;attempt to unlock read lock, not locked by current thread&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 共享锁加锁</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*
         * Walkthrough:
         * 1. If write lock held by another thread, fail.
         * 2. Otherwise, this thread is eligible for
         *    lock wrt state, so ask if it should block
         *    because of queue policy. If not, try
         *    to grant by CASing state and updating count.
         *    Note that step does not check for reentrant
         *    acquires, which is postponed to full version
         *    to avoid having to check hold count in
         *    the more typical non-reentrant case.
         * 3. If step 2 fails either because thread
         *    apparently not eligible or CAS fails or count
         *    saturated, chain to version with full retry loop.
         */</span>
        <span class="token comment">/**
         * tryAcquireShared方法的执行逻辑如下，
         * 1. 如果有其他线程持有写锁，则加锁失败，返回-1
         * 2.1. 判断当前线程加读锁是否需要阻塞
         * 2.2. 读锁数量还没有达到上限
         * 2.3. 调用cas方法更新同步属性state的值，尝试加读锁
         * 2.4. 如果加锁成功，把当前线程对应的HoldCounter对象的count+1
         * 3. 如果第二步失败，则调用带有循环的全力加锁方法fullTryAcquireShared()
         */</span>
        <span class="token comment">// 拿到当前线程</span>
        <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取同步属性state的值</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 判断，如果当前有线程持有写锁，并且不是当前线程，则加锁失败，返回-1</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
            <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> current<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取当前读锁的重入次数</span>
        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果，1. 加读锁不需要阻塞；2. 读锁的个数没超过上限；3. cas更新同步属性state的值成功，则</span>
        <span class="token comment">// 进入if代码块</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            r <span class="token operator">&lt;</span> MAX_COUNT <span class="token operator">&amp;&amp;</span>
            <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> SHARED_UNIT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 加锁成功后，</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果原本的读锁的数量是0</span>
                <span class="token comment">// 代表当前线程是第一个加读锁的线程，那就把这个线程赋值给firstReader，</span>
                <span class="token comment">// 然后给firstReaderHoldCount赋值1</span>
                firstReader <span class="token operator">=</span> current<span class="token punctuation">;</span>
                firstReaderHoldCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 当前线程是第一个加读锁的线程，现在是该线程又加了一个读锁，直接firstReaderHoldCount+1</span>
                firstReaderHoldCount<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                 <span class="token comment">// 当前线程不是第一个加读锁的线程，那么就把该线程对应的HoldCounter对象（如果没有，就初始化一个）的属性count+1</span>
                <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token comment">// 如果rh还等于空，或者cached这个HoldCounter对象不是当前线程的HoldCounter，</span>
                    <span class="token comment">// 那就从threadLocal获取属于当前线程的HoldCounter对象</span>
                    cachedHoldCounter <span class="token operator">=</span> rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    readHolds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span>
                rh<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 加锁成功，返回1</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 代码执行到这里，还没有加锁成功，大概率是因为，</span>
        <span class="token comment">// 1. 判断到当前线程加读锁需要阻塞</span>
        <span class="token comment">// 2. cas更新同步属性state的值失败</span>
        <span class="token comment">// 3. 读锁已经达到上限</span>
        <span class="token comment">// 那么就调用fullTryAcquireShared()方法，准备全力尝试添加读锁，加锁成功返回1，加锁失败返回-1</span>
        <span class="token keyword">return</span> <span class="token function">fullTryAcquireShared</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 全力尝试添加读锁</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">fullTryAcquireShared</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*
         * This code is in part redundant with that in
         * tryAcquireShared but is simpler overall by not
         * complicating tryAcquireShared with interactions between
         * retries and lazily reading hold counts.
         */</span>
        <span class="token comment">// 这个方法和tryAcquireShared()差不多，相当于是死循环版本的tryAcquireShared()</span>
        <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 获取当前同步属性的state的值</span>
            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 判断当前是否有线程持有写锁</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果当前有线程持有写锁，判断持有写锁的线程是不是当前线程</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> current<span class="token punctuation">)</span>
                    <span class="token comment">// 如果不是，返回-1，方法执行结束</span>
                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token comment">// ？问题1 - 这里没理解</span>
                <span class="token comment">// 否则，当前线程会持有一个写锁，在这里阻塞会导致死锁</span>
                <span class="token comment">// else we hold the exclusive lock; blocking here</span>
                <span class="token comment">// would cause deadlock.</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 代码执行到这里，代表当前没有写锁，然后读锁需要阻塞</span>
                <span class="token comment">// Make sure we're not acquiring read lock reentrantly</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// assert firstReaderHoldCount &gt; 0;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 如果当前线程不是第一个加读锁的线程，那么就判断下当前线程持有的HoldCounter对象的count的值</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token comment">// 如果rh还等于空，或者cached这个HoldCounter对象不是当前线程的HoldCounter，</span>
                            <span class="token comment">// 那就从threadLocal获取属于当前线程的HoldCounter对象</span>
                            rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                                readHolds<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 如果当前线程对应的HoldCounter对象的count == 0，则返回-1</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 如果读锁的重入次数达到最大值，抛出错误</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> MAX_COUNT<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 调用AQS类的compareAndSetState()方法，更新同步属性state的值，尝试加读锁</span>
            <span class="token comment">// 这里有一个细节，</span>
            <span class="token comment">// 可以看到，最外层的是一个死循环，那就代表说，</span>
            <span class="token comment">// 如果，1. 一直没有写锁；2. 当前加读锁不需要阻塞；3. 读锁数量没有达到上限</span>
            <span class="token comment">// 则会一直在循环中调用cas方法更新state添加读锁，直到加锁成功（所以此方法名称为：全力添加读锁）</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> SHARED_UNIT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 加锁成功后，如果原本的读锁的数量是0</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 代表当前线程是第一个加读锁的线程，那就把这个线程赋值给firstReader，</span>
                    <span class="token comment">// 然后给firstReaderHoldCount赋值1</span>
                    firstReader <span class="token operator">=</span> current<span class="token punctuation">;</span>
                    firstReaderHoldCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 当前线程是第一个加读锁的线程，现在是该线程又加了一个读锁，直接firstReaderHoldCount+1</span>
                    firstReaderHoldCount<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 当前线程不是第一个加读锁的线程，那么就把该线程对应的HoldCounter对象（如果没有，就初始化一个）的属性count+1</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                        rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token comment">// 如果rh还等于空，或者cached这个HoldCounter对象不是当前线程的HoldCounter，</span>
                        <span class="token comment">// 那就从threadLocal获取属于当前线程的HoldCounter对象</span>
                        rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        readHolds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    rh<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
                    cachedHoldCounter <span class="token operator">=</span> rh<span class="token punctuation">;</span> <span class="token comment">// cache for release</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 加锁成功，返回1</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 尝试加写锁，如果加锁失败，则返回false，不阻塞</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 拿到当前线程</span>
        <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 拿到当前同步属性state的值</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 当c != 0时，代表有线程持有锁</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 根据获取当前写锁的加锁次数</span>
            <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 这里分为两种情况</span>
            <span class="token comment">// 1. w == 0，代表当前有线程持有读锁，读写互斥，加锁失败，直接返回false；</span>
            <span class="token comment">// 2. w != 0，代表当前有线程持有写锁，也说明当前只有写锁，因为读写互斥，然后进一步判断，发现当前线程并不是是持有写锁的线程，加锁失败，直接返回false。</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> current <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment">// 代码执行到这里，说明当前只有写锁，并且是当前线程持有写锁</span>
            <span class="token comment">// 那就判断w的值，如果已经等于可重入的最大值，就不能再加锁了，所以需要抛出一个错误</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">==</span> MAX_COUNT<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      	<span class="token comment">// 代码执行到这里，说明当前没有线程持有锁，那么直接调用AQS类的cas方法，原子更新state的值，尝试添加写锁</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">// 如果加锁失败，返回false</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">// 代码执行到这里，代表当前线程添加写锁成功，那就把这个线程设置为当前持有独占锁的线程</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 最后，加锁成功，返回true</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 尝试加读锁，如果加锁失败，则返回false，不阻塞</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 拿到当前线程</span>
        <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 拿到当前同步属性state的值</span>
            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 这里分两种情况</span>
          	<span class="token comment">// 1. 判断现在是否有线程持有写锁，</span>
            <span class="token comment">//		1.1. 如果没有，代码向下执行</span>
            <span class="token comment">// 2. 如果有，进一步判断，持有写锁的线程是不是当前线程，</span>
          	<span class="token comment">//		2.1. 如果是，代码向下执行</span>
          	<span class="token comment">//		2.1. 如果不是，代表有其他线程持有写锁，读写互斥，加锁失败，直接返回false</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
                <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> current<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
          	<span class="token comment">// 拿到当前读锁的加锁次数</span>
            <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
          	<span class="token comment">// 如果读锁的加锁次数已经达到最大值，直接抛出错误</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> MAX_COUNT<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          	<span class="token comment">// 代码执行到这里，代表现在可以添加读锁，</span>
          	<span class="token comment">// 于是直接调用AQS类的cas方法，原子更新state的值，尝试添加读锁。</span>
          	<span class="token comment">// 至于，为什么是用c + SHARED_UNIT来更新state，请参考上文对SHARED_UNIT常量的分析。</span>
            <span class="token comment">// 而且这里还有一个细节，</span>
          	<span class="token comment">// 可以看到，代码的最外层是一个死循环，也就是说，如果上面代码的判断一直都不满足，</span>
          	<span class="token comment">// 当前方法会一直循环，然后一直调用compareAndSetState方法，保证加读锁成功</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> SHARED_UNIT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 加读锁成功后，有一些额外的操作</span>
                <span class="token comment">// 如果r == 0，代表当前线程是第一个添加读锁的线程</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  	<span class="token comment">// 那就把这个线程保存一下</span>
                    firstReader <span class="token operator">=</span> current<span class="token punctuation">;</span>
                  	<span class="token comment">// 并且把firstReaderHoldCount+1</span>
                    firstReaderHoldCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  	<span class="token comment">// 如果r != 0，代表已经有读锁了，那就判断一下当前线程是不是第一个加读锁的线程，</span>
                  	<span class="token comment">// 如果是，那就代表现在是第一个加读锁的线程又加了一次读锁，</span>
                  	<span class="token comment">// 就直接把firstReaderHoldCount+1</span>
                    firstReaderHoldCount<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 如果上面条件都不满足，那就代表当前是一个（非首个加读锁的）线程尝试加读锁</span>
                    <span class="token comment">// 那就直接获取当前线程持有的HoldCounter的对象，获取不到就初始化一个</span>
                  	<span class="token comment">// 然后把其中的计数器count+1</span>
                    <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
                        cachedHoldCounter <span class="token operator">=</span> rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        readHolds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    rh<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 最后，加读锁成功，返回true</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 判断当前线程是不是持有独占锁的线程</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// While we must in general read state before owner,</span>
        <span class="token comment">// we don't need to do so to check if current thread is owner</span>
        <span class="token keyword">return</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Methods relayed to outer class</span>
    <span class="token comment">// 返回一个条件锁对象</span>
    <span class="token keyword">final</span> <span class="token class-name">ConditionObject</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConditionObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前持有独占锁的线程</span>
    <span class="token keyword">final</span> <span class="token class-name">Thread</span> <span class="token function">getOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Must read state before owner to ensure memory consistency</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                <span class="token keyword">null</span> <span class="token operator">:</span>
                <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前读锁的重入次数</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getReadLockCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前有没有线程持有独占锁</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isWriteLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前持有独占锁的重入次数</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getWriteHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前线程持有的读锁的重入次数</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getReadHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getReadLockCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span>
            <span class="token keyword">return</span> firstReaderHoldCount<span class="token punctuation">;</span>

        <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> rh<span class="token punctuation">.</span>tid <span class="token operator">==</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> rh<span class="token punctuation">.</span>count<span class="token punctuation">;</span>

        <span class="token keyword">int</span> count <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> readHolds<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 定义了一个反序列化时会调用的方法，将当前对象设置为无锁状态</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>io<span class="token punctuation">.</span><span class="token class-name">ObjectInputStream</span> s<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span><span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        s<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        readHolds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalHoldCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reset to unlocked state</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前读锁和写锁一共的重入次数，也就是AQS类的同步属性state的值</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="fairsync"><a href="#fairsync" class="header-anchor">#</a> FairSync</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 公平锁子类</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2274990926593161451L</span><span class="token punctuation">;</span>
    <span class="token comment">// 公平锁的判断比较简单，读锁、写锁是否需要阻塞，都调用了AQS类的hasQueuedPredecessors()方法</span>
    <span class="token comment">// hasQueuedPredecessors()方法的详细分析请查看AQS类分析的那篇文章</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="nofairsync"><a href="#nofairsync" class="header-anchor">#</a> NoFairSync</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 非公平锁子类</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">8159625535654395037L</span><span class="token punctuation">;</span>
    <span class="token comment">// 非公平锁的写锁，不需要阻塞</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// writers can always barge</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 非公平锁的读锁是否要阻塞，是调用了AQS类的apparentlyFirstQueuedIsExclusive()方法进行判断的，</span>
  	<span class="token comment">// apparentlyFirstQueuedIsExclusive()方法的详细分析请查看AQS类分析的那篇文章</span>
  	<span class="token comment">/**  
		 * apparentlyFirstQueuedIsExclusive()方法的大致意思是：
     * 如果，1. 等待队列的第一个等待线程不为空；2.这个等待线程要加是独占锁，那就返回true，代表需要阻塞。
     * 
     * 这个方法，实际上是为了避免写锁线程一直等待拿不到锁；场景如下，
     * 假设当前第一个排队的线程是等待写锁，然后来了一个读锁，
     * 那么即便是初始化的非公平的读写锁，这个读锁也必须去排队，而不能直接抢锁。
     */</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* As a heuristic to avoid indefinite writer starvation,
               * block if the thread that momentarily appears to be head
               * of queue, if one exists, is a waiting writer.  This is
               * only a probabilistic effect since a new reader will not
               * block if there is a waiting writer behind other enabled
               * readers that have not yet drained from the queue.
               */</span>
      <span class="token keyword">return</span> <span class="token function">apparentlyFirstQueuedIsExclusive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后，ReentrantReadWriteLock还定义了两个Lock接口的内部实现类，一个读锁，一个写锁，分别是ReadLock和WriteLock。这两个实现类都持有一个Sync的实例属性，下面直接看源码进行分析。</p> <h3 id="readlock"><a href="#readlock" class="header-anchor">#</a> ReadLock</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ReadLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span><span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5992448646407690164L</span><span class="token punctuation">;</span>
    <span class="token comment">// 内部持有一个Sync的属性变量</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>
    <span class="token comment">// 初始化读锁</span>
    <span class="token keyword">protected</span> <span class="token class-name">ReadLock</span><span class="token punctuation">(</span><span class="token class-name">ReentrantReadWriteLock</span> lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sync <span class="token operator">=</span> lock<span class="token punctuation">.</span>sync<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 尝试添加读锁，如果第一次加锁失败之后，会进入等待队列，不响应中断</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sync<span class="token punctuation">.</span><span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 尝试添加读锁，如果第一次加锁失败之后，会进入等待队列，可响应中断</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 尝试添加读锁，如果第一次添加失败之后，直接返回false，不阻塞</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryReadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 尝试添加读锁，如果第一次加锁失败之后，会进入等待队列，超时后会返回false，可响应中断</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireSharedNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 释放读锁</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用sync的releaseShared()方法，独占锁释放</span>
        sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 读锁不支持条件锁，直接抛出异常</span>
    <span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 重写了toString方法，返回了当前读锁的重入次数</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> r <span class="token operator">=</span> sync<span class="token punctuation">.</span><span class="token function">getReadLockCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
            <span class="token string">&quot;[Read locks = &quot;</span> <span class="token operator">+</span> r <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="writelock"><a href="#writelock" class="header-anchor">#</a> WriteLock</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WriteLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span><span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">4992448646407690164L</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>
    <span class="token comment">// 初始化写锁</span>
    <span class="token keyword">protected</span> <span class="token class-name">WriteLock</span><span class="token punctuation">(</span><span class="token class-name">ReentrantReadWriteLock</span> lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sync <span class="token operator">=</span> lock<span class="token punctuation">.</span>sync<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 添加写锁，如果第一次添加失败之后，会进入等待队列，不响应中断</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用sync的release()方法，独占锁加锁</span>
        sync<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 添加写锁，如果第一次添加失败之后，会进入等待队列，可响应中断</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 默认是调用了AQS类的acquireInterruptibly()方法</span>
        <span class="token comment">// 关于acquireInterruptibly()方法的分析，请参考AQS类分析的文章</span>
        sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 尝试加写锁，如果第一次加锁失败，直接返回false，不阻塞</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用sync的tryWriteLock()方法，尝试添加写锁</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 尝试加写锁，如果第一次加锁失败之后，会进入等待队列，超时后会返回false，可响应中断</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 释放写锁</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用sync的release()方法，独占锁释放</span>
        sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 写锁获取条件锁，直接调用sync的newCondition()方法，返回一个条件锁</span>
    <span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 重写了toString方法，返回了当前持有读锁的线程名称</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Thread</span> o <span class="token operator">=</span> sync<span class="token punctuation">.</span><span class="token function">getOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                                   <span class="token string">&quot;[Unlocked]&quot;</span> <span class="token operator">:</span>
                                   <span class="token string">&quot;[Locked by thread &quot;</span> <span class="token operator">+</span> o<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前线程是不是持有写锁</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isHeldByCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前写锁的重入次数</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">getWriteHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后，再来看下ReentrantReadWriteLock自身提供的主要方法。</p> <h3 id="reentrantreadwritelock-2"><a href="#reentrantreadwritelock-2" class="header-anchor">#</a> ReentrantReadWriteLock</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantReadWriteLock</span>
        <span class="token keyword">implements</span> <span class="token class-name">ReadWriteLock</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span><span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">6992448646407690164L</span><span class="token punctuation">;</span>
    <span class="token comment">/** Inner class providing readlock */</span>
    <span class="token comment">// 读锁变量</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">.</span><span class="token class-name">ReadLock</span> readerLock<span class="token punctuation">;</span>
    <span class="token comment">/** Inner class providing writelock */</span>
  	<span class="token comment">// 写锁变量</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">.</span><span class="token class-name">WriteLock</span> writerLock<span class="token punctuation">;</span>
    <span class="token comment">/** Performs all synchronization mechanics */</span>
    <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span>
    <span class="token comment">// 默认初始化为非公平锁</span>
    <span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 可以传入true来初始化一个公平锁</span>
    <span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        readerLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReadLock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        writerLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WriteLock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ReadWriteLock接口的实现，返回一个写锁</span>
    <span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">.</span><span class="token class-name">WriteLock</span> <span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> writerLock<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// ReadWriteLock接口的实现，返回一个读锁</span>
    <span class="token keyword">public</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">.</span><span class="token class-name">ReadLock</span>  <span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> readerLock<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">// Instrumentation and status</span>
    <span class="token comment">// 返回当前是不是公平锁</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isFair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync <span class="token keyword">instanceof</span> <span class="token class-name">FairSync</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前持有写锁的线程</span>
    <span class="token keyword">protected</span> <span class="token class-name">Thread</span> <span class="token function">getOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">getOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前读锁的重入次数</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getReadLockCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">getReadLockCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前是否有线程持有写锁</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isWriteLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">isWriteLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回是否是当前线程持有写锁</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isWriteLockedByCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前写锁的重入次数</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getWriteHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">getWriteHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前线程持有的读锁的重入次数</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getReadHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">getReadHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前等待队列中要获取写锁的所有线程的集合</span>
    <span class="token keyword">protected</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">&gt;</span></span> <span class="token function">getQueuedWriterThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">getExclusiveQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前等待队列中要获取读锁的所有线程的集合</span>
    <span class="token keyword">protected</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">&gt;</span></span> <span class="token function">getQueuedReaderThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">getSharedQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前等待队列中是否有线程在等待获取锁</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前线程是否在等待队列中排队</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">isQueued</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前等待队列的长度</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getQueueLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">getQueueLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前等待队列中的所有线程的集合</span>
    <span class="token keyword">protected</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">&gt;</span></span> <span class="token function">getQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">getQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回condition的条件队列是否有线程在等待获取锁</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasWaiters</span><span class="token punctuation">(</span><span class="token class-name">Condition</span> condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>condition <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>condition <span class="token keyword">instanceof</span> <span class="token class-name">AbstractQueuedSynchronizer</span><span class="token punctuation">.</span><span class="token class-name">ConditionObject</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;not owner&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">hasWaiters</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AbstractQueuedSynchronizer</span><span class="token punctuation">.</span><span class="token class-name">ConditionObject</span><span class="token punctuation">)</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回condition的条件队列的长度</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getWaitQueueLength</span><span class="token punctuation">(</span><span class="token class-name">Condition</span> condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>condition <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>condition <span class="token keyword">instanceof</span> <span class="token class-name">AbstractQueuedSynchronizer</span><span class="token punctuation">.</span><span class="token class-name">ConditionObject</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;not owner&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">getWaitQueueLength</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AbstractQueuedSynchronizer</span><span class="token punctuation">.</span><span class="token class-name">ConditionObject</span><span class="token punctuation">)</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回condition的条件队列中的所有线程的集合</span>
    <span class="token keyword">protected</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">&gt;</span></span> <span class="token function">getWaitingThreads</span><span class="token punctuation">(</span><span class="token class-name">Condition</span> condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>condition <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>condition <span class="token keyword">instanceof</span> <span class="token class-name">AbstractQueuedSynchronizer</span><span class="token punctuation">.</span><span class="token class-name">ConditionObject</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;not owner&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">getWaitingThreads</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AbstractQueuedSynchronizer</span><span class="token punctuation">.</span><span class="token class-name">ConditionObject</span><span class="token punctuation">)</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 重写了toString方法，返回了读锁和写锁的数量</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> sync<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token class-name">Sync</span><span class="token punctuation">.</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token class-name">Sync</span><span class="token punctuation">.</span><span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
            <span class="token string">&quot;[Write locks = &quot;</span> <span class="token operator">+</span> w <span class="token operator">+</span> <span class="token string">&quot;, Read locks = &quot;</span> <span class="token operator">+</span> r <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// </span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">getLongVolatile</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> TID_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Unsafe mechanics</span>
    <span class="token comment">// 定义了一个Unsafe的常量</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span><span class="token class-name">Unsafe</span> UNSAFE<span class="token punctuation">;</span>
    <span class="token comment">// 定义了一个属性，保存当前线程的tid属性相对于线程对象的偏移量</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> TID_OFFSET<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            UNSAFE <span class="token operator">=</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span><span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> tk <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
            TID_OFFSET <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span>objectFieldOffset
                <span class="token punctuation">(</span>tk<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">&quot;tid&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上文中有部分方法是在AQS类中实现的，这里做一下标注，可点击跳转，查看源码分析。</p> <ol><li><a href="/java/aqs.html#compareAndSet">AbstractQueuedSynchronizer#compareAndSetState</a></li> <li><a href="/java/aqs.html#hasQueuedPredecessors">AbstractQueuedSynchronizer#hasQueuedPredecessors</a></li> <li><a href="/java/aqs.html#apparentlyFirstQueuedIsExclusive">AbstractQueuedSynchronizer#apparentlyFirstQueuedIsExclusive</a></li> <li><a href="/java/aqs.html#acquire">AbstractQueuedSynchronizer#acquire</a></li> <li><a href="/java/aqs.html#acquireInterruptibly">AbstractQueuedSynchronizer#acquireInterruptibly</a></li> <li><a href="/java/aqs.html#acquireShared">AbstractQueuedSynchronizer#acquireShared</a></li> <li><a href="/java/aqs.html#acquireSharedInterruptibly">AbstractQueuedSynchronizer#acquireSharedInterruptibly</a></li></ol> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ol><li>ReentrantReadWriteLock没有实现Lock，而是持有了两个Lock的实现类的实例属性，分别是ReentrantReadWriteLock.ReadLock和ReentrantReadWriteLock.WriteLock。</li> <li>ReentrantReadWriteLock的读锁是共享锁，写锁是互斥锁。读读不互斥，读写互斥，写写互斥。</li> <li>ReentrantReadWriteLock是可重入锁。</li> <li>ReentrantReadWriteLock默认是非公平锁，可以在调用构造方法时传入true定义成公平锁。</li></ol></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/itForeverYoung/blog/edit/master/docs/java/ReentrantReadWriteLock.md" target="_blank" rel="noopener noreferrer">在GitHub上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">6/8/2020, 7:08:08 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/java/ReentrantLock.html" class="prev">
        ReentrantLock
      </a></span> <span class="next"><a href="/java/StampedLock.html">
        StampedLock
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7059aeb2.js" defer></script><script src="/assets/js/2.d76243a0.js" defer></script><script src="/assets/js/48.94d48ed5.js" defer></script>
  </body>
</html>
