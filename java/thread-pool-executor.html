<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Executor | IT Forever Young</title>
    <meta name="generator" content="VuePress 1.5.3">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="IT Forever Young">
    <link rel="preload" href="/assets/css/0.styles.a1e33db5.css" as="style"><link rel="preload" href="/assets/js/app.54d83c99.js" as="script"><link rel="preload" href="/assets/js/2.686cfa6a.js" as="script"><link rel="preload" href="/assets/js/67.5ab34c14.js" as="script"><link rel="prefetch" href="/assets/js/10.13b7cdd0.js"><link rel="prefetch" href="/assets/js/100.3ad11df4.js"><link rel="prefetch" href="/assets/js/101.e72bd3e4.js"><link rel="prefetch" href="/assets/js/102.094741b5.js"><link rel="prefetch" href="/assets/js/103.d03257a8.js"><link rel="prefetch" href="/assets/js/104.fed64bba.js"><link rel="prefetch" href="/assets/js/105.1e9907f2.js"><link rel="prefetch" href="/assets/js/106.2ff53c87.js"><link rel="prefetch" href="/assets/js/107.5ce2f6e7.js"><link rel="prefetch" href="/assets/js/11.5faf38bd.js"><link rel="prefetch" href="/assets/js/12.febde73e.js"><link rel="prefetch" href="/assets/js/13.b42041b3.js"><link rel="prefetch" href="/assets/js/14.60f0f377.js"><link rel="prefetch" href="/assets/js/15.8836d1b9.js"><link rel="prefetch" href="/assets/js/16.7cbf7d0d.js"><link rel="prefetch" href="/assets/js/17.1f032d1b.js"><link rel="prefetch" href="/assets/js/18.078448df.js"><link rel="prefetch" href="/assets/js/19.7116bab5.js"><link rel="prefetch" href="/assets/js/20.3aba382e.js"><link rel="prefetch" href="/assets/js/21.0cef3b0f.js"><link rel="prefetch" href="/assets/js/22.3289e77d.js"><link rel="prefetch" href="/assets/js/23.b9f68191.js"><link rel="prefetch" href="/assets/js/24.d403a3de.js"><link rel="prefetch" href="/assets/js/25.d43851c3.js"><link rel="prefetch" href="/assets/js/26.a159f233.js"><link rel="prefetch" href="/assets/js/27.7a88b74d.js"><link rel="prefetch" href="/assets/js/28.eb01c171.js"><link rel="prefetch" href="/assets/js/29.b52114e6.js"><link rel="prefetch" href="/assets/js/3.340d59ec.js"><link rel="prefetch" href="/assets/js/30.24abd5ab.js"><link rel="prefetch" href="/assets/js/31.ad976921.js"><link rel="prefetch" href="/assets/js/32.2ae9ff05.js"><link rel="prefetch" href="/assets/js/33.b6a015d0.js"><link rel="prefetch" href="/assets/js/34.c4917469.js"><link rel="prefetch" href="/assets/js/35.0e949986.js"><link rel="prefetch" href="/assets/js/36.dd8e57af.js"><link rel="prefetch" href="/assets/js/37.3ebe283b.js"><link rel="prefetch" href="/assets/js/38.18442b48.js"><link rel="prefetch" href="/assets/js/39.760a62a1.js"><link rel="prefetch" href="/assets/js/4.6c47412e.js"><link rel="prefetch" href="/assets/js/40.8d513a07.js"><link rel="prefetch" href="/assets/js/41.953e179f.js"><link rel="prefetch" href="/assets/js/42.db9646a2.js"><link rel="prefetch" href="/assets/js/43.862586ff.js"><link rel="prefetch" href="/assets/js/44.cc212440.js"><link rel="prefetch" href="/assets/js/45.bfeda571.js"><link rel="prefetch" href="/assets/js/46.0fd18ad1.js"><link rel="prefetch" href="/assets/js/47.e19b9e0a.js"><link rel="prefetch" href="/assets/js/48.0b56a7d5.js"><link rel="prefetch" href="/assets/js/49.7463045a.js"><link rel="prefetch" href="/assets/js/5.4f73075e.js"><link rel="prefetch" href="/assets/js/50.13b60131.js"><link rel="prefetch" href="/assets/js/51.d5e42e68.js"><link rel="prefetch" href="/assets/js/52.a20a5d72.js"><link rel="prefetch" href="/assets/js/53.a7cc41bc.js"><link rel="prefetch" href="/assets/js/54.a3ed4961.js"><link rel="prefetch" href="/assets/js/55.cf3698f1.js"><link rel="prefetch" href="/assets/js/56.f1df664a.js"><link rel="prefetch" href="/assets/js/57.1ffde18c.js"><link rel="prefetch" href="/assets/js/58.36d0140e.js"><link rel="prefetch" href="/assets/js/59.791a78a7.js"><link rel="prefetch" href="/assets/js/6.b4d21898.js"><link rel="prefetch" href="/assets/js/60.5a18b32e.js"><link rel="prefetch" href="/assets/js/61.bdfb4b54.js"><link rel="prefetch" href="/assets/js/62.b5c00605.js"><link rel="prefetch" href="/assets/js/63.35ac0eb8.js"><link rel="prefetch" href="/assets/js/64.c9f1006f.js"><link rel="prefetch" href="/assets/js/65.437c5e7a.js"><link rel="prefetch" href="/assets/js/66.f3ef69dd.js"><link rel="prefetch" href="/assets/js/68.1af0cafe.js"><link rel="prefetch" href="/assets/js/69.f467579d.js"><link rel="prefetch" href="/assets/js/7.6fdab028.js"><link rel="prefetch" href="/assets/js/70.f593a29c.js"><link rel="prefetch" href="/assets/js/71.672e7926.js"><link rel="prefetch" href="/assets/js/72.ce4603cd.js"><link rel="prefetch" href="/assets/js/73.23992200.js"><link rel="prefetch" href="/assets/js/74.23886f73.js"><link rel="prefetch" href="/assets/js/75.440b08fa.js"><link rel="prefetch" href="/assets/js/76.088a3bf4.js"><link rel="prefetch" href="/assets/js/77.bfd7d7e8.js"><link rel="prefetch" href="/assets/js/78.5136b125.js"><link rel="prefetch" href="/assets/js/79.f3adec86.js"><link rel="prefetch" href="/assets/js/8.62bb549e.js"><link rel="prefetch" href="/assets/js/80.549fde63.js"><link rel="prefetch" href="/assets/js/81.534f8c8c.js"><link rel="prefetch" href="/assets/js/82.b480be70.js"><link rel="prefetch" href="/assets/js/83.84226740.js"><link rel="prefetch" href="/assets/js/84.6832a5ab.js"><link rel="prefetch" href="/assets/js/85.c1f0df99.js"><link rel="prefetch" href="/assets/js/86.5b5883c0.js"><link rel="prefetch" href="/assets/js/87.b0ac9807.js"><link rel="prefetch" href="/assets/js/88.77ab5a8d.js"><link rel="prefetch" href="/assets/js/89.045092b7.js"><link rel="prefetch" href="/assets/js/9.528e6fd1.js"><link rel="prefetch" href="/assets/js/90.73754a85.js"><link rel="prefetch" href="/assets/js/91.0b9b4a5c.js"><link rel="prefetch" href="/assets/js/92.ffbc851a.js"><link rel="prefetch" href="/assets/js/93.ac97c10e.js"><link rel="prefetch" href="/assets/js/94.7970ff71.js"><link rel="prefetch" href="/assets/js/95.299178fb.js"><link rel="prefetch" href="/assets/js/96.7e318b86.js"><link rel="prefetch" href="/assets/js/97.ffe03daf.js"><link rel="prefetch" href="/assets/js/98.0b824852.js"><link rel="prefetch" href="/assets/js/99.1ecdce0a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a1e33db5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">IT Forever Young</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/java/" class="nav-link router-link-active">
  Java
</a></div><div class="nav-item"><a href="/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/spring/" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/redis/" class="nav-link">
  Redis
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试专题
</a></div><div class="nav-item"><a href="/open/" class="nav-link">
  随便分享
</a></div> <a href="https://github.com/itForeverYoung/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/java/" class="nav-link router-link-active">
  Java
</a></div><div class="nav-item"><a href="/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/spring/" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/redis/" class="nav-link">
  Redis
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  面试专题
</a></div><div class="nav-item"><a href="/open/" class="nav-link">
  随便分享
</a></div> <a href="https://github.com/itForeverYoung/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/juc.html" class="sidebar-link">JUC 并发编程包</a></li><li><a href="/java/aqs.html" class="sidebar-link">AbstractQueuedSynchronizer</a></li><li><a href="/java/ReentrantLock.html" class="sidebar-link">ReentrantLock</a></li><li><a href="/java/ReentrantReadWriteLock.html" class="sidebar-link">ReentrantReadWriteLock</a></li><li><a href="/java/CountDownLatch.html" class="sidebar-link">CountDownLatch</a></li><li><a href="/java/CyclicBarrier.html" class="sidebar-link">CyclicBarrier</a></li><li><a href="/java/Semaphore.html" class="sidebar-link">Semaphore</a></li><li><a href="/java/thread-pool-executor.html" aria-current="page" class="active sidebar-link">Executor</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/thread-pool-executor.html#问题" class="sidebar-link">问题</a></li><li class="sidebar-sub-header"><a href="/java/thread-pool-executor.html#源码分析" class="sidebar-link">源码分析</a></li><li class="sidebar-sub-header"><a href="/java/thread-pool-executor.html#扩展" class="sidebar-link">扩展</a></li><li class="sidebar-sub-header"><a href="/java/thread-pool-executor.html#总结" class="sidebar-link">总结</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="executor"><a href="#executor" class="header-anchor">#</a> Executor</h1> <p>线程池也是并发编程中最常使用的技术之一，池化的目的，就是为了节约资源，提高效率，本文就简要分析下线程池的实现原理。</p> <h2 id="问题"><a href="#问题" class="header-anchor">#</a> 问题</h2> <ol><li>线程有几种状态？</li> <li>如何初始化一个线程池，几个参数的意义是什么？</li></ol> <h2 id="源码分析"><a href="#源码分析" class="header-anchor">#</a> 源码分析</h2> <h3 id="executor-2"><a href="#executor-2" class="header-anchor">#</a> Executor</h3> <p>Executor是一个接口，很简单，就定义了一个execute方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 提交任务到线程池执行</span>
<span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="executeservice"><a href="#executeservice" class="header-anchor">#</a> ExecuteService</h3> <p>ExecuteService也是一个接口，它继承了Executor，并扩展了一些方法，带返回类型的submit方法就是它提供的。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 关闭线程池，调用此方法后，线程池不再接收新任务，但是会把队列中的任务执行完再关闭</span>
<span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 立刻关闭线程池，调用此方法后，线程池会立刻关闭，并返回队列中还未执行的任务集合</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回线程池是不是关闭状态，</span>
<span class="token keyword">boolean</span> <span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回线程池是不是终止状态，</span>
<span class="token keyword">boolean</span> <span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 可以调用此方法，监控线程池的终止</span>
<span class="token keyword">boolean</span> <span class="token function">awaitTermination</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
<span class="token comment">// 有返回值，提交一个callable任务到线程池</span>
<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 提交一个runnable任务到线程池，并附带一个泛型对象用来接收返回值</span>
<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">T</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 提交一个runnable任务到线程池，实际上是获取不到任务的返回值的</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 下面还提供了一些invoke方法，暂未分析</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><h3 id="abstractexecutorservice"><a href="#abstractexecutorservice" class="header-anchor">#</a> AbstractExecutorService</h3> <p>AbstractExecutorService是一个抽象类，它实现了ExecuteService接口，并且实现了submit和invoke相关的方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 根据runnable和一个泛型对象初始化一个FutureTask实例，FutureTask继承了RunnableFuture接口，RunnableFuture接口同时继承了Runnable和Future接口</span>
<span class="token keyword">protected</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">,</span> <span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 根据callable初始化一个FutureTask实例</span>
<span class="token keyword">protected</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 提交一个runnable任务到线程池，虽然该runnable也被包装成了FutureTask，但是调用FutureTask.get()是获取不到任务的返回值的</span>
<span class="token keyword">public</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 提交一个runnable任务和一个泛型对象到线程池，泛型对象是用来接收返回值的</span>
<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">T</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 提交一个callable任务到线程池，可调用future.get()来获取返回值</span>
<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="threadpoolexecutor"><a href="#threadpoolexecutor" class="header-anchor">#</a> ThreadPoolExecutor</h3> <p>一般来说，ThreadPoolExecutor是最常使用的线程池，下面就来分析一下源码。</p> <h4 id="常量分析"><a href="#常量分析" class="header-anchor">#</a> 常量分析</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/** 
 * 重中之重，ThreadPoolExecutor用一个AtomicInteger的变量保存了两个属性，
 * workerCount（低29位），runState（高3位）
 */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// COUNT_BITS=29，已知Integer.SIZE=32</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token comment">// CAPACITY=536870911，可以看出来，很大，1 &lt;&lt; COUNT_BITS等同于2^29-1</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 池的运行状态存储在高3位
 * 下面一一列出线程池的5种状态，每种状态的值依次递增，
 * 即RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED
 */</span>

<span class="token comment">// 高3位为111，值是-536870912，代表可以接收任务并处理</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>
<span class="token comment">/**
 * 高3位为000，值为0，调用shutdown()会进入此状态，
 * 不再接收新任务，但是会将队列中的任务执行完
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>
<span class="token comment">/**
 * 计算结果为：
 * 1
 * 0000 0000 0000 0000 0000 0000 0000 0001
 * 1 &lt;&lt; 29
 * 0010 0000 0000 0000 0000 0000 0000 0000
 * 高3位为001，值为536870912，调用shutdownNow()会进入此状态，
 * 不再接收新任务，不会执行队列中的任务，并且会中断当前执行中的任务
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>
<span class="token comment">/**
 * 计算结果为：
 * 2
 * 0000 0000 0000 0000 0000 0000 0000 0010
 * 2 &lt;&lt; 29
 * 0100 0000 0000 0000 0000 0000 0000 0000
 * 高3位为010，值为1073741824，当队列和池都是空的时候会进入此状态，
 * 所有的任务都被终止，线程数为0，池进入此状态后，会调用terminated()钩子方法
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>
<span class="token comment">/**
 * 计算结果为：
 * 3
 * 0000 0000 0000 0000 0000 0000 0000 0011
 * 3 &lt;&lt; 29
 * 0110 0000 0000 0000 0000 0000 0000 0000
 * 高3位为011，值为1610612736，terminated()钩子方法执行完会进入此状态，
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>
</code></pre></div><h4 id="基础方法分析"><a href="#基础方法分析" class="header-anchor">#</a> 基础方法分析</h4> <p>下面提供了一些原子更新线程池状态值ctl的方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 下面是包装和拆包ctl的方法</span>

<span class="token comment">// 获取当前池的运行状态</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token comment">// 获取当前池中的线程数</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token comment">// 根据rs和wc获取一个ctl值</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token comment">// 当前的状态是不是小于s</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">runStateLessThan</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c <span class="token operator">&lt;</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 当前的状态至少为s</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c <span class="token operator">&gt;=</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 判断当前线程池是不是运行状态</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isRunning</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> c <span class="token operator">&lt;</span> SHUTDOWN<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// worker的数量加1，原子操作</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> ctl<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>expect<span class="token punctuation">,</span> expect <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// worker的数量减1，原子操作</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> ctl<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>expect<span class="token punctuation">,</span> expect <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// worker的数量减1，原子操作</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="主要方法分析"><a href="#主要方法分析" class="header-anchor">#</a> 主要方法分析</h4> <h5 id="execute"><a href="#execute" class="header-anchor">#</a> execute</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/*
   * 总体来说，分为4步：
   * 1. 添加核心线程执行任务，
   * 2. 如果核心线程数达到上限，则将任务入队，
   * 3. 如果入队失败，则添加非核心线程执行任务，
   * 4. 如果非核心线程也达到上限，则执行拒绝策略。
   */</span>
  <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果此时worker的数量小于核心线程数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 则调用addWorker方法添加worker，添加成功后直接返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">// 否则，再次获取当前线程池的ctl值</span>
    c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果当前线程池是运行状态，并且worker的数量已经大于等于核心线程数，则将任务入队</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果线程入队成功，重新获取当前的线程池的状态值</span>
    <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果此时池的状态变成了非运行，则从队列中清除当前任务</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">// 然后执行拒绝策略</span>
      <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 这里重新检查下当前的worker的数量，如果为0，则添加一个worker</span>
    <span class="token comment">// 为什么这么做？因为如果当前任务入队，但是没有worker了，就会出现明明有任务在队列，但是没有线程去执行的情况</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token comment">// 所以如果worker==0，就添加一个worker</span>
      <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果work数量达到了coreSize，并且任务入队失败（可能是队列满了），</span>
  <span class="token comment">// 那就尝试再次添加worker（此时添加的worker是非核心的线程）</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">//如果此时添加失败，就代表任务入队失败，并且非核心线程也达到了上限，那就要执行拒绝策略了</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="addworker"><a href="#addworker" class="header-anchor">#</a> addWorker</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 添加worker线程</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  retry<span class="token operator">:</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前线程池的状态</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取当前线程池的运行状态</span>
    <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Check if queue empty only if necessary.</span>
    <span class="token comment">/**
     * 如果线程池的状态是SHUTDOWN，并且队列不为空，并且firstTask为空（代表此时没有任务提交），
     * 返回false
     * （也就是说，你都要SHUTDOWN了，就别再添加空的worker线程了）
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>
        <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>
           firstTask <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
           <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 走到这里，代表线程池是运行状态</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 获取当前的已有的worker线程数</span>
      <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">/** 
       * 如果worker线程数已经达到了CAPACITY最大值，
       * 或者worker线程数已经达到了corePoolSize（core=true）或者maximumPoolSize（core=false）时，
       * 返回false
       * （也就是说，您都要溢出来了，还加啥加）
       */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">&gt;=</span> CAPACITY <span class="token operator">||</span>
          wc <span class="token operator">&gt;=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token comment">// 将当前worker线程数+1（cas原子操作），若成功，则跳出两层死循环，执行后序代码</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span> retry<span class="token punctuation">;</span>
      
      <span class="token comment">// 走到这里，代表ctl+1失败，所以需要重新获取一下当前的ctl值</span>
      c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Re-read ctl</span>
      <span class="token comment">// 重新判断下当前线程池的运行状态，</span>
      <span class="token comment">// 如果不等于rs（RUNNING），代表线程池可能关闭了，重新走一下上边的状态判断</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>
        <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>
      <span class="token comment">// 如果状态没有变化，则继续内层循环，尝试进行ctl+1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 标识符，worker是否启动成功</span>
  <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token comment">// 标识符，worker是否添加成功</span>
  <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token class-name">Worker</span> w <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建一个worker实例</span>
    w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取该实例持有的线程，此时，线程t应该是NEW状态</span>
    <span class="token keyword">final</span> <span class="token class-name">Thread</span> t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 加锁</span>
      <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
      mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 拿到锁之后，再次检查下当前线程池的运行状态</span>
        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 当rs运行状态为RUNNING时，</span>
        <span class="token comment">// 或者，rs为SHUTDOWN，并且firstTask为空（此时没有任务提交）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>
            <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">/** 
           * 进入if代码块，说明线程池还没有关闭，那么就要判断下worker线程的状态
           * 新建的worker应该是NEW状态，如果这个worker线程已经是RUNNABLE状态了，说明有问题，就得抛出异常
           * isAlive方法是判断线程是不是启动而且还没有死亡
           */</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// precheck that t is startable</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 如果一切OK，那就将新建的这个worker添加到集合中</span>
          workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 获取集合的size，填充到largestPoolSize属性中</span>
          <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> largestPoolSize<span class="token punctuation">)</span>
            largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>
          <span class="token comment">// 更新added状态，worker添加成功</span>
          workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 解锁</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 当worker添加成功后，启动该worker的线程</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 启动线程</span>
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 更新started状态，worker启动成功</span>
        workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果worker启动失败，则需要将这个worker清除，即调用addWorkerFailed()方法</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>
      <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 最后，返回worker线程是否启动成功</span>
  <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 1. 从worker集合中清除该worker
 * 2. ctl的worker数量-1
 * 3. 
 */</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
  <span class="token comment">// 加锁</span>
  mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果worker不为空，那就从集合中清除这个worker</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 然后把workerCount-1</span>
    <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 添加worker失败了，可能是出现了什么异常，那么就判断下现在要不要终止线程池</span>
    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// 解锁</span>
    mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="runworker"><a href="#runworker" class="header-anchor">#</a> runWorker</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// runWorker方法是worker线程启动后真正要执行的方法，下文会分析Worker类的定义</span>
<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拿到当前线程，其实也就是worker持有的线程</span>
  <span class="token class-name">Thread</span> wt <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 拿到要执行的第一个任务，如果创建worker时没有传入，则为空</span>
  <span class="token class-name">Runnable</span> task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>
  <span class="token comment">// 然后将firstTask置空</span>
  w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// Worker类继承了AQS类，这里调用unlock方法，其实是为了将state设置为0，并且把独占线程设置为空</span>
  w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// allow interrupts</span>
  <span class="token comment">// 标识符，是否突然完成？</span>
  <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">/**
     * 这里有两种情况
     * 1. worker第一次执行时，可能有一个初始任务，也就是firstTask不为空，那task就不为空，进入while代码块
     * 2. 如果worker不是第一次执行或者没有初始任务，那就调用getTask方法从队列中获取一个任务，进入while代码块
     * 如果没有任务要执行了，跳出while代码块
     */</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// worker加锁</span>
      w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">/**
       * 这里会再次确认一下线程池的状态，分析一下这个if语句，
       * 条件1. !wt.isInterrupted()，如果worker持有的线程没有被中断，
       * 条件2.1. runStateAtLeast(ctl.get(), STOP)，如果线程池被关闭了，
       * 条件2.2. Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)，如果线程被中断了，并且线程池关闭了。
       * 
       * 其实这里有点绕，就是为什么明明是||操作，但是条件2.2里还要再判断一次条件2.1，源码注释就在下面，然后，简单分析下：
       * 这里判断的目的，就是为了保证两件事：
       * 1. 如果线程池停止了，那就要保证每一个worker线程都被中断；（条件1+条件2.1）
       * 2. 如果线程池没有停止，那就要保证每一个worker线程都没有被中断；
       *
       * 下面就把所有可能出现的情况列举一下：
       * 1. 条件2.1判断时，线程池被关闭了，线程的中断状态时false，进入if代码块，中断线程，保证了上述事件1；
       * 2. 条件2.1判断时，线程池被关闭了，线程的中断状态时true，不会进入if代码块，保证了上述事件1；
       * 3. 条件2.1判断时，线程池没被关闭，条件2.2判断时，线程被中断了，线程池被关闭了，进入if代码块，中断线程，保证了上述事件1；
       * 4. 条件2.1判断时，线程池没被关闭，条件2.2判断时，线程被中断了，但是线程池没被关闭，不会进入if代码块，保证了上述事件2；
       * 
       * 这里还要强调一下，为什么在条件2.2里还要再判断一次条件2.1，
       * 是因为，如果在条件2.1判断返回false后，线程池被shutdownNow方法关闭了，那么就会直接将线程池设置为STOP并且中断所有worker线程；
       * 但是为了保证事件2，这里判断线程是否被中断，调用的是Thread.interrupted()，这个方法在返回了线程的中断状态后，会重置线程的中断状态（即将线程的中断状态设置为false），那么此时，条件1一定为true；
       * 所以，为了要恢复线程的中断状态，这里需要进入if代码块，重新中断一次线程。
       */</span>
      <span class="token comment">// If pool is stopping, ensure thread is interrupted;</span>
      <span class="token comment">// if not, ensure thread is not interrupted.  This</span>
      <span class="token comment">// requires a recheck in second case to deal with</span>
      <span class="token comment">// shutdownNow race while clearing interrupt</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>
           <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
          <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 执行任务前调用，空方法，给子类重写的（扩展点1）</span>
        <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 定义一个异常，如果</span>
        <span class="token class-name">Throwable</span> thrown <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token comment">// 真正执行runnable任务的地方</span>
          task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
          <span class="token comment">// 执行任务后调用，空方法，给子类重写的（扩展点2）</span>
          <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将task置空</span>
        task <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 已完成的task总数+1</span>
        w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment">// worker解锁</span>
        w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将是否突然完成的标识符设置为false</span>
    completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里的completedAbruptly主要是判断当前worker是不是出异常了，只有当try代码块抛出异常时，completedAbruptly才不会被赋值，那么就代表workerCount没有被-1，就需要在processWorkerExit方法中做特殊处理</span>
    <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="gettask"><a href="#gettask" class="header-anchor">#</a> getTask</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// get task，从线程池的队列中获取一个任务</span>
<span class="token keyword">private</span> <span class="token class-name">Runnable</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 是否超时，标识符</span>
  <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Did the last poll() time out?</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前线程池的状态值</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取线程池的运行状态</span>
    <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * 如果线程池已关闭，或者线程池处于SHUTDOWN状态并且队列为空
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">&gt;=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将worker的数量-1</span>
      <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 返回null</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
		<span class="token comment">// 获取线程池已创建的worker的数量</span>
    <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * 判断当前是否需要淘汰线程，
     * 如果1. 允许核心线程被淘汰（这里说明了，可以通过设置allowCoreThreadTimeOut属性，让核心线程在指定时间内没获取到任务也被停止），
     * 或者2. 当前线程数超过了核心线程（这里就说明了，如果非核心线程在指定时间内还没获取到任务，就会被停止），
     * 那timed=true。
     * allowCoreThreadTimeOut默认为false，并且构造方法中没有出来该参数，
     * 不过，可以通过调用java.util.concurrent.ThreadPoolExecutor#allowCoreThreadTimeOut方法进行设置
     */</span>
    <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">&gt;</span> corePoolSize<span class="token punctuation">;</span>
    <span class="token comment">/**
     * 这个if语句我们拆开来看，它是两个||语句的&amp;&amp;组合，那么就会有4种情况，
     * 1. 如果线程池已创建的线程数wc大于最大线程数maximumPoolSize，并且wc大于1，
     * 2. 如果线程池已创建的线程数wc大于最大线程数maximumPoolSize，并且队列为空，
     * 3. 如果允许核心线程超时（timed），并且判断到核心线程已超时（timedOut），并且wc大于1，
     * 4. 如果允许核心线程超时（timed），并且判断到核心线程已超时（timedOut），并且队列为空。
     * 其实，2，4两种情况很好理解，等待队列为空，当前没有要执行的任务了，那么就要关闭非核心线程，非核心线程关完了，就判断下核心线程时候可以关闭，如果可以，那就同样去关闭核心线程；
     * 但是，1，3又是什么意思呢？先看1，
     * 以上几种情况，都会将当前已启动的线程数-1，并且返回空
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">&gt;</span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">/** 
       * 这里就比较简单，从队列中获取一个任务，有两种情况，
       * 1. 如果核心线程允许被关闭，也就是上边的timed==true，
       *    那这里就调用可设置超时的poll方法从队列中获取任务，一旦超时了，还没有拿到任务，就将timedOut设置为true；
       * 2. 如果核心线程不允许被关闭，也就是上边的timed==false，
       *    那就调用阻塞的take方法从队列中获取任务，直到拿到了任务再返回。
       */</span>
      <span class="token class-name">Runnable</span> r <span class="token operator">=</span> timed <span class="token operator">?</span>
        workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span>
      workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 如果拿到任务了，返回改任务，方法执行结束</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> r<span class="token punctuation">;</span>
      <span class="token comment">// 如果没有拿到任务，那就肯定是超时了，那就把timedOut设置为true，因为take方法会一直阻塞，直到拿到任务，只有poll方法设置了超时</span>
      timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 当线程被中断的时候，把timedOut设置为false</span>
      timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="processworkerexit"><a href="#processworkerexit" class="header-anchor">#</a> processWorkerExit</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// processWorkerExit方法只有一个调用者，那就是runWorker方法</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processWorkerExit</span><span class="token punctuation">(</span><span class="token class-name">Worker</span> w<span class="token punctuation">,</span> <span class="token keyword">boolean</span> completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果completedAbruptly==true，说明在runWorker方法出现异常了，那就说明workerCount没有-1</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>completedAbruptly<span class="token punctuation">)</span> <span class="token comment">// If abrupt, then workerCount wasn't adjusted</span>
    <span class="token comment">// 这里就需要将workerCount-1</span>
    <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 获取锁对象</span>
  <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
  <span class="token comment">// 加锁</span>
  mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 把当前线程总共执行了多少个任务数量加到线程池的总任务数completedTaskCount上</span>
    completedTaskCount <span class="token operator">+=</span> w<span class="token punctuation">.</span>completedTasks<span class="token punctuation">;</span>
    <span class="token comment">// 把当前worker线程从集合中移除</span>
    workers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// 解锁</span>
    mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	<span class="token comment">// 判断下现在要不要终止线程池</span>
  <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 获取当前线程池的状态值</span>
  <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果线程池还没有被关闭，可能是RUNNING，也可能是SHUTDOWN</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 并且completedAbruptly==false，也就是说</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>completedAbruptly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 获取线程池最小的线程数，如果允许核心线程关闭，那么最小就为0，否则最小为corePoolSize</span>
      <span class="token keyword">int</span> min <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> corePoolSize<span class="token punctuation">;</span>
      <span class="token comment">// 如果min==0，即极端情况下，线程池中可能一个线程都没有；</span>
      <span class="token comment">// 但是此时任务队列还不为空，说明还有任务在等待执行，那么就给min赋值1</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
      <span class="token comment">// 如果目前线程池中的worker数量大于等于min，说明现在线程池里至少有一个在运行的worker线程，那就没问题，直接返回就OK</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> min<span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// replacement not needed</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果completedAbruptly==true，或者当前线程池中一个worker都没有了，这里就需要添加一个非核心线程</span>
    <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="tryterminate"><a href="#tryterminate" class="header-anchor">#</a> tryTerminate</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 判断下是否要终止线程池</span>
<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前线程池的状态值</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * 如果满足以下三种情况，直接返回
     * 1. 线程池正在运行（不能终止）；
     * 2. 线程池已经处于TIDYING（整理）或者TERMINATED（终止）状态（已经被终止了）；
     * 3. 线程池处于SHUTDOWN状态，但是队列中还有没执行完的任务（不能终止）。
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> TIDYING<span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * 如果当前的worker数量还大于0，说明还有worker线程没有被停止，
     * 那么这里就调用interruptIdleWorkers方法去中断一个worker，那这个worker可以被停止。
     * ONLY_ONE==true，所以每次调用interruptIdleWorkers方法都只会中断一个线程，
     * 中断完，直接返回。
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Eligible to terminate</span>
      <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span>ONLY_ONE<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
		<span class="token comment">// 拿到锁</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    <span class="token comment">// 加锁</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// 首先更新线程池的状态为TIDYING，说明此时线程池已经进入了收尾整理阶段</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span>TIDYING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token comment">// 线程池关闭时调用，空方法，给子类重写的（扩展点3）</span>
          <span class="token function">terminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
          <span class="token comment">// 将线程池的状态更新为TERMINATED，此时，线程池就被关闭了</span>
          ctl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>TERMINATED<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">/** 在线程池初始化的时候就会初始化termination条件锁，
           * 并且ExecuteServic提供了awaitTermination方法供外部调用，ThreadPoolExecutor实现了这个方法，
           * 在该方法中，所有await的线程都会进入条件队列等待被termination唤醒，
           * 所有，当线程池关闭后，这里就调用了signAll方法，唤醒所有等待当前线程池终止的XX线程。
           */</span>
          termination<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
      <span class="token comment">// 解锁</span>
      mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// else retry on failed CAS</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="worker"><a href="#worker" class="header-anchor">#</a> Worker</h5> <p>ThreadPoolExecutor中定义了一个Worker类，继承了AQS类，同时也实现了Runnable接口，Worker类的实现还是比较简单的。</p> <p>那么它为什么要继承AQS类？</p> <ol><li>为了保证在worker线程正在执行任务时，不会被其他操作影响；</li> <li>也可以通过worker是否处于加锁状态来判断该worker是否正在执行任务。</li></ol> <p>可以自行结合interruptIdleWorkers方法或getActiveCount方法进行分析。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>
  <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>
  <span class="token keyword">implements</span> <span class="token class-name">Runnable</span>
<span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">6138294804551838833L</span><span class="token punctuation">;</span>
  <span class="token comment">// 当前worker所持有的线程，从pool中获取的</span>
  <span class="token keyword">final</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
  <span class="token comment">// 需要执行的任务，可能为空</span>
  <span class="token class-name">Runnable</span> firstTask<span class="token punctuation">;</span>
  <span class="token comment">// 单个线程的任务计数器，记录执行了多少个任务</span>
  <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>
  <span class="token comment">// 构造方法</span>
  <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// inhibit interrupts until runWorker</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>
    <span class="token comment">// 从线程工厂中生成一个线程</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	<span class="token comment">// 代理了外面的runWorker()方法</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	<span class="token comment">/**
	 * 下面是与锁相关的方法
	 * Worker启动后只有两种状态
	 * 1. state==0，无锁状态
	 * 2. state==1，加锁状态
	 */</span>
	<span class="token comment">// 返回当前是不是有锁状态，即state != 0</span>
  <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	<span class="token comment">// 加锁，就是将state从0设置为1，设置成功返回true，失败返回false</span>
  <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	<span class="token comment">// 释放锁，就是将state设置为0</span>
  <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	<span class="token comment">// 加锁，就调用父类的acquire，然后acquire调用了tryAcquire</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">// tryLock就直接调用tryAcquire</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">// 释放锁，就调用父类的release，然后release调用了tryRelease</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">// 判断当前worker是不是加锁状态</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token comment">// 如果worker持有的线程已启动，那就给这个线程发送一个中断信号</span>
  <span class="token keyword">void</span> <span class="token function">interruptIfStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> t<span class="token punctuation">;</span>
    <span class="token comment">// state初始为-1，当state&gt;=0时，说明worker启动了；worker持有的thread不为空；并且该线程没有被中断过</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> thread<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 那就给这个线程发送一个中断信号</span>
        t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="其他方法分析"><a href="#其他方法分析" class="header-anchor">#</a> 其他方法分析</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 将线程池的状态修改为targetState，一般是更新为SHUTDOWN或STOP时调用，</span>
<span class="token comment">// 更新为TIDYING或TERMINATED由tryTerminate方法处理</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">advanceRunState</span><span class="token punctuation">(</span><span class="token keyword">int</span> targetState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取当前线程池的状态</span>
        <span class="token comment">/**
         * 1. 如果当前状态大于target状态，那就不做操作，直接返回
         * 2. 否则，就更新线程池的状态为targetState
         */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> targetState<span class="token punctuation">)</span> <span class="token operator">||</span>
            ctl<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span>targetState<span class="token punctuation">,</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 如果有安全管理器的话，就要验证下，方法调用者是否有权限关闭worker线程</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">SecurityManager</span> security <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>security <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        security<span class="token punctuation">.</span><span class="token function">checkPermission</span><span class="token punctuation">(</span>shutdownPerm<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
        mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Worker</span> w <span class="token operator">:</span> workers<span class="token punctuation">)</span>
                security<span class="token punctuation">.</span><span class="token function">checkAccess</span><span class="token punctuation">(</span>w<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 给所有已启动的线程发送中断信号</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">interruptWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Worker</span> w <span class="token operator">:</span> workers<span class="token punctuation">)</span>
            w<span class="token punctuation">.</span><span class="token function">interruptIfStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 给空闲线程发送中断信号</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> onlyOne<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 遍历当前所有worker</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Worker</span> w <span class="token operator">:</span> workers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span> t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> w<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 如果onlyOne==true，那就是只给一个空闲线程发送完中断信号后就会返回</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>onlyOne<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 给所有空闲线程发送中断信号</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 执行拒绝策略</span>
<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    handler<span class="token punctuation">.</span><span class="token function">rejectedExecution</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 将任务队列中的所有任务添加到集合中</span>
<span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token function">drainQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> q <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>
    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> taskList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果可以直接转化成list，那q就一定是空的</span>
    q<span class="token punctuation">.</span><span class="token function">drainTo</span><span class="token punctuation">(</span>taskList<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果q != null，说明上面转化失败了，那就挨个从队列中清除，然后添加到集合中</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Runnable</span> r <span class="token operator">:</span> q<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
                taskList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> taskList<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 关闭线程池，将线程池的状态修改为SHUTDOWN，此时不允许再提交任务，但是会把现有的任务都执行完</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token comment">// 将线程池状态设置为SHUTDOWN</span>
        <span class="token function">advanceRunState</span><span class="token punctuation">(</span>SHUTDOWN<span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token comment">// 给所有空闲线程发送中断信号</span>
        <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token comment">// 当线程池即将关闭时调用，空方法，给子类重写的（扩展点4）</span>
        <span class="token function">onShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hook for ScheduledThreadPoolExecutor</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 立刻关闭线程池，将线程池的状态修改为STOP，此时不允许再提交任务，而且会将任务队列中的任务输出到集合中</span>
<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> tasks<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token comment">// 将线程池状态设置为STOP</span>
        <span class="token function">advanceRunState</span><span class="token punctuation">(</span>STOP<span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token comment">// 给所有已启动的线程发送中断信号</span>
        <span class="token function">interruptWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token comment">// 获取队列中所有还未执行的任务</span>
        tasks <span class="token operator">=</span> <span class="token function">drainQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> tasks<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 判断线程池是不是停止了，只要不是运行状态，就返回true</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 判断线程池是不是处于终止中，只要线程池不是RUNNING，也不是TERMINATED，就返回true</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isTerminating</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">runStateLessThan</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> TERMINATED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 判断线程池是不是终止了</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TERMINATED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 实现了ExecutorService接口的方法，提供给外部调用的方法，
 * 当其他线程调用了此方法，就会在限时内进入条件队列，
 * 如果当前线程池被终止了，其他线程就会被termination.signAll方法唤醒，返回true，否则，返回false
 */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">awaitTermination</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TERMINATED<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            nanos <span class="token operator">=</span> termination<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 如果当前线程数小于核心线程数，那就启动一个核心线程</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">prestartCoreThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize <span class="token operator">&amp;&amp;</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 确保一定预启动一个线程，如果corePoolSize&gt;0，那就预启动一个核心线程；如果corePoolSize==0，那么就预启动一个非核心线程</span>
<span class="token keyword">void</span> <span class="token function">ensurePrestart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 预启动所有核心线程，并返回启动了几个</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">prestartAllCoreThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token operator">++</span>n<span class="token punctuation">;</span>
    <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="可用于更新或监控的方法分析"><a href="#可用于更新或监控的方法分析" class="header-anchor">#</a> 可用于更新或监控的方法分析</h4> <p>ThreadPoolExecutor有个比较好的地方在于，所有的属性都可以被修改，这样也就给我们提供了监控，动态修改线程池属性的方式。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 构造方法</span>
<span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                            <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                            <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                            <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                            <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                            <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                            <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>
        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>
        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>acc <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span>
            <span class="token keyword">null</span> <span class="token operator">:</span>
            <span class="token class-name">AccessController</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 设置线程工厂</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setThreadFactory</span><span class="token punctuation">(</span><span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>threadFactory <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 返回现在的线程工厂</span>
<span class="token keyword">public</span> <span class="token class-name">ThreadFactory</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> threadFactory<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 设置拒绝策略</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 返回拒绝策略</span>
<span class="token keyword">public</span> <span class="token class-name">RejectedExecutionHandler</span> <span class="token function">getRejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 设置核心线程数</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCorePoolSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 计算刚设置的核心线程数和原本的值的差值</span>
    <span class="token keyword">int</span> delta <span class="token operator">=</span> corePoolSize <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>
    <span class="token comment">// 如果当前已启动的线程数大于核心线程数，就给所有空闲的线程发送一个中断信号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> corePoolSize<span class="token punctuation">)</span>
        <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里的操作呢，其实也是想赶紧把所有的任务执行完。</span>
        <span class="token comment">// 如果delta大于0，说明刚设置的核心线程数大于原本的值</span>
        <span class="token comment">// 那就从差值delta和当前的队列长度中选一个比较小的值</span>
        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>delta<span class="token punctuation">,</span> workQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 接下来会尽量启动k个核心线程</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token operator">--</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 由于启动过程中，队列中的任务也是一直在被执行，所以，一旦队列空了，也就没有必要再加核心线程了</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取当前核心线程数</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCorePoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> corePoolSize<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 设置最大线程数</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMaximumPoolSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> maximumPoolSize <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>
    <span class="token comment">// 如果当前已启动的线程数大于最大线程数，就给所有空闲的线程发送一个中断信号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> maximumPoolSize<span class="token punctuation">)</span>
        <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取当前最大线程数</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getMaximumPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> maximumPoolSize<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 重新设置线程的超时时间</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setKeepAliveTime</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">allowsCoreThreadTimeOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Core threads must have nonzero keep alive times&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> delta <span class="token operator">=</span> keepAliveTime <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> keepAliveTime<span class="token punctuation">;</span>
    <span class="token comment">// 这里呢，就是说，如果新的超时时间，比旧的超时时间短，那就给所有空闲的线程发送一个中断信号</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取当前设置的线程超时时间</span>
<span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getKeepAliveTime</span><span class="token punctuation">(</span><span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> unit<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取任务的等待队列</span>
<span class="token keyword">public</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> <span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> workQueue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取现在正在执行中的worker的个数</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getActiveCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>
    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Worker</span> w <span class="token operator">:</span> workers<span class="token punctuation">)</span>
            <span class="token comment">// worker被锁了，说明正在执行任务</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token operator">++</span>n<span class="token punctuation">;</span>
        <span class="token keyword">return</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 返回是否允许核心线程超时</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">allowsCoreThreadTimeOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> allowCoreThreadTimeOut<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 设置是否允许核心线程超时</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">allowCoreThreadTimeOut</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&amp;&amp;</span> keepAliveTime <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Core threads must have nonzero keep alive times&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> allowCoreThreadTimeOut<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        allowCoreThreadTimeOut <span class="token operator">=</span> value<span class="token punctuation">;</span>
      	<span class="token comment">// 如果允许核心线程超时，那这里就给所有空闲的线程发送一个中断信号</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span>
            <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="futuretask"><a href="#futuretask" class="header-anchor">#</a> FutureTask</h3> <p>上面主要讲了execute方法提交任务的实现逻辑，submit方法提交任务的实现逻辑主要在FutureTask类中，</p> <p>FutureTask实现了RunnableFuture接口，而RunnableFuture就是Runnable和Future的合体，</p> <p>所以下面先简单看下Future接口定义了哪些方法。</p> <h5 id="future"><a href="#future" class="header-anchor">#</a> Future</h5> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 取消任务，mayInterruptIfRunning==true时，会给执行任务的线程发送一个中断信号</span>
<span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 判断任务是否取消</span>
<span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 判断任务是否执行完成</span>
<span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取任务执行的结果</span>
<span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">;</span>
<span class="token comment">// 带有超时的返回结果，在指定时间内未得到结果，抛出TimeoutException异常</span>
<span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">;</span>
</code></pre></div><p>然后，再分析下FutureTask类的实现逻辑。</p> <h5 id="futuretask-2"><a href="#futuretask-2" class="header-anchor">#</a> FutureTask</h5> <h6 id="常量分析-2"><a href="#常量分析-2" class="header-anchor">#</a> 常量分析</h6> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * FutureTask类中定义了一组常量，用来表示当前任务的执行状态
 * 可能的状态转换有以下几种
 * NEW -&gt; COMPLETING -&gt; NORMAL
 * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL
 * NEW -&gt; CANCELLED
 * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED
 */</span>
<span class="token comment">// 新建</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NEW          <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">// 完成中</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COMPLETING   <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">// 正常</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NORMAL       <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// 异常</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXCEPTIONAL  <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token comment">// 取消</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED    <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token comment">// 中断中</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTING <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token comment">// 已中断</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTED  <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
</code></pre></div><h6 id="主要方法分析-2"><a href="#主要方法分析-2" class="header-anchor">#</a> 主要方法分析</h6> <p>我按照大概的执行流程，将方法重新排序，下面依次分析。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 定义了一个简单的内部类，这个类主要维护了一个等待当前任务执行结束的线程队列</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">WaitNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token class-name">WaitNode</span> next<span class="token punctuation">;</span>
    <span class="token class-name">WaitNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> thread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 构造方法，传入一个Runnable和泛型result，通过调用Executors.callable()得到一个RunnableAdapter，RunnableAdapter实现了Callable，这里应用了适配器模式。</span>
<span class="token keyword">public</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> runnable<span class="token punctuation">,</span> <span class="token class-name">V</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">callable</span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token punctuation">;</span>       <span class="token comment">// ensure visibility of callable</span>
<span class="token punctuation">}</span>
<span class="token comment">// 构造方法，传入一个Callable，初始化FutureTask</span>
<span class="token keyword">public</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>callable <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> callable<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token punctuation">;</span>       <span class="token comment">// ensure visibility of callable</span>
<span class="token punctuation">}</span>
<span class="token comment">// 核心方法，FutureTask实现了Runnable接口，所以，当任务提交到线程池之后，真正执行的方法就是这个run方法</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 从上面的构造方法可以看出，当任务刚刚执行的时候，state一定是NEW，</span>
    <span class="token comment">// 然后，这里会把当前线程赋值给FutureTask的runner属性，也就是执行该任务的线程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> NEW <span class="token operator">||</span>
        <span class="token operator">!</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> runnerOffset<span class="token punctuation">,</span>
                                        <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 拿到要执行的callable</span>
        <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> callable<span class="token punctuation">;</span>
        <span class="token comment">// 此时callable不为空，state == NEW，任务开始执行</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> state <span class="token operator">==</span> NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 定义result接收返回值</span>
            <span class="token class-name">V</span> result<span class="token punctuation">;</span>
            <span class="token comment">// 保存callable是执行成功还是失败的标识符</span>
            <span class="token keyword">boolean</span> ran<span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 调用call方法，得到返回值</span>
                result <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 正常执行，ran = true</span>
                ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 一旦出现异常，说明任务执行失败，把result置空，并调用setException方法将当前任务的执行状态设置为EXCEPTIONAL</span>
                result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token function">setException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 如果正常返回，则调用set方法设置result</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ran<span class="token punctuation">)</span>
                <span class="token function">set</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// runner must be non-null until state is settled to</span>
        <span class="token comment">// prevent concurrent calls to run()</span>
        <span class="token comment">// 最后，要把FutureTask持有的runner设置为空</span>
        runner <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// state must be re-read after nulling runner to prevent</span>
        <span class="token comment">// leaked interrupts</span>
        <span class="token comment">// 此处还要判断下任务的执行状态，如果大于等于INTERRUPTING，说明这个线程被中断了</span>
        <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;=</span> INTERRUPTING<span class="token punctuation">)</span>
            <span class="token comment">// 那就调用handlePossibleCancellationInterrupt方法，将当前任务的执行状态设置为INTERRUPTED</span>
            <span class="token function">handlePossibleCancellationInterrupt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// runAndReset方法是给子类调用的，和run方法差不多，区别有三点</span>
<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">runAndReset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> NEW <span class="token operator">||</span>
        <span class="token operator">!</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> runnerOffset<span class="token punctuation">,</span>
                                        <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> callable<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> s <span class="token operator">==</span> NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 1. 这里没有给result赋值，说明当前方法不会返回任务执行的结果</span>
                c<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// don't set result</span>
                ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果出现任务执行出错，一样需要把执行状态修改为EXCEPTIONAL</span>
                <span class="token function">setException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 2. 这里没有调用set方法，说明在正常执行的情况下，FutureTask的state应该一直是NEW</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// runner must be non-null until state is settled to</span>
        <span class="token comment">// prevent concurrent calls to run()</span>
        <span class="token comment">// 同样把执行线程置空</span>
        runner <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// state must be re-read after nulling runner to prevent</span>
        <span class="token comment">// leaked interrupts</span>
        s <span class="token operator">=</span> state<span class="token punctuation">;</span>
        <span class="token comment">// 判断是否被中断</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;=</span> INTERRUPTING<span class="token punctuation">)</span>
            <span class="token function">handlePossibleCancellationInterrupt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 3. 任务执行成功后，应该是返回true，一旦任务执行失败或者执行线程被中断，这里都会返回false</span>
    <span class="token keyword">return</span> ran <span class="token operator">&amp;&amp;</span> s <span class="token operator">==</span> NEW<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 设置返回值</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">V</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先将当前task状态设置为COMPLETING</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NEW<span class="token punctuation">,</span> COMPLETING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 设置task执行结果</span>
        outcome <span class="token operator">=</span> v<span class="token punctuation">;</span>
        <span class="token comment">// 将task状态设置为NORMAL，正常已完成</span>
        UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NORMAL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// final state</span>
        <span class="token comment">// task正常执行完成，调用finishCompletion方法唤醒所有等待task执行结束的线程</span>
        <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">setException</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先将当前task状态设置为COMPLETING</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NEW<span class="token punctuation">,</span> COMPLETING<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 设置task执行结果</span>
        outcome <span class="token operator">=</span> t<span class="token punctuation">;</span>
        <span class="token comment">// 将task状态设置为EXCEPTIONAL，异常</span>
        UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> EXCEPTIONAL<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// final state</span>
        <span class="token comment">// task异常执行完成，调用finishCompletion方法唤醒所有等待task执行结束的线程</span>
        <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 唤醒所有正在等待task完成的线程</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// assert state &gt; COMPLETING;</span>
    <span class="token comment">// 当前方法一定是task执行状态大于COMPLETING才会被调用</span>
    <span class="token comment">// 如果waiters不等于null，说明的确有线程在等待，那就开始循环线程的等待队列</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">WaitNode</span> q<span class="token punctuation">;</span> <span class="token punctuation">(</span>q <span class="token operator">=</span> waiters<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 首先把waiters属性置空</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span> q<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 死循环</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 得到等待的线程</span>
                <span class="token class-name">Thread</span> t <span class="token operator">=</span> q<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>
                <span class="token comment">// 如果线程不为空</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   	<span class="token comment">// 先将node持有的thread属性释放掉</span>
                    q<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token comment">// 唤醒这个线程</span>
                    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 拿到当前node的下一个node</span>
                <span class="token class-name">WaitNode</span> next <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token comment">// 释放掉上一个节点持有的当前节点的引用，加速gc</span>
                q<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// unlink to help gc</span>
                q <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
	<span class="token comment">// 所以等待线程都被唤醒了之后调用，空方法，留给子类重写（扩展点5）</span>
    <span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将task的callable属性置空</span>
    callable <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// to reduce footprint</span>
<span class="token punctuation">}</span>
<span class="token comment">// 如果当前的task的执行状态为INTERRUPTING，那就说明有线程在中断这个执行任务的线程，那就让当前线程调用yield方法让出cpu（这里要注意，让出cpu，不代表放弃抢占cpu，很有可能，当前线程刚让出cpu就立刻抢占了cpu），直到task的执行状态不为INTERRUPTING之后，执行结束，执行结束后，状态一定为INTERRUPTED。</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handlePossibleCancellationInterrupt</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// It is possible for our interrupter to stall before getting a</span>
    <span class="token comment">// chance to interrupt us.  Let's spin-wait patiently.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> INTERRUPTING<span class="token punctuation">)</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> INTERRUPTING<span class="token punctuation">)</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// wait out pending interrupt</span>

    <span class="token comment">// assert state == INTERRUPTED;</span>

    <span class="token comment">// We want to clear any interrupt we may have received from</span>
    <span class="token comment">// cancel(true).  However, it is permissible to use interrupts</span>
    <span class="token comment">// as an independent mechanism for a task to communicate with</span>
    <span class="token comment">// its caller, and there is no way to clear only the</span>
    <span class="token comment">// cancellation interrupt.</span>
    <span class="token comment">//</span>
    <span class="token comment">// Thread.interrupted();</span>
<span class="token punctuation">}</span>
<span class="token comment">/** 
 * 取消任务，有两种情况，
 * mayInterruptIfRunning==true时，表示需要中断线程，task的执行状态NEW-&gt;INTERRUPTING-&gt;INTERRUPTED
 * mayInterruptIfRunning==false时，将task的执行状态设置为CANCELLED即可。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/**
     * 如果state != NEW，或者修改task状态失败后，返回false，代表任务取消失败。
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>state <span class="token operator">==</span> NEW <span class="token operator">&amp;&amp;</span>
            UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NEW<span class="token punctuation">,</span>
                mayInterruptIfRunning <span class="token operator">?</span> INTERRUPTING <span class="token operator">:</span> CANCELLED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// in case call to interrupt throws exception</span>
        <span class="token comment">// 如果mayInterruptIfRunning==true，说明要中断线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mayInterruptIfRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span> t <span class="token operator">=</span> runner<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    <span class="token comment">// 中断执行task的线程</span>
                    t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment">// final state</span>
                <span class="token comment">// 最后，将state更新为INTERRUPTED</span>
                UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> INTERRUPTED<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// task取消后，也要调用finishCompletion方法唤醒所有等待task执行结束的线程</span>
        <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回true，取消task成功</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// state &gt;= CANCELLED，代表任务取消成功</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> state <span class="token operator">&gt;=</span> CANCELLED<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 只要状态state != NEW，就说明这个task执行结束了</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> state <span class="token operator">!=</span> NEW<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 请注意一点，调用get()方法的线程，一定是其他线程，即不是执行task的线程，
 * 那么，如果get()方法中，发现任务一直没有执行结束，这个其他线程就会进入等待队列，也就是保存到task的waiters属性
 */</span>

<span class="token comment">// 获取任务的返回值</span>
<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取当前task的状态</span>
    <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>
    <span class="token comment">// 如果小于等于COMPLETING，说明还没完成</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;=</span> COMPLETING<span class="token punctuation">)</span>
        <span class="token comment">// 那就进入等待吧</span>
        s <span class="token operator">=</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 调用report方法得到任务执行的结果</span>
    <span class="token keyword">return</span> <span class="token function">report</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 带有超时时间的获取任务的返回值</span>
<span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>unit <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取当前task的状态</span>
    <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>
    <span class="token comment">/** 如果小于等于COMPLETING，说明还没完成，那就进入超时等待吧，
     * 一旦超时返回后，发现task的状态还是小于等于COMPLETING，就说明任务还没有返回，是超时了，那就抛出TimeoutException异常
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;=</span> COMPLETING <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>s <span class="token operator">=</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> COMPLETING<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 调用report方法得到任务执行的结果</span>
    <span class="token keyword">return</span> <span class="token function">report</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取任务结果</span>
<span class="token keyword">private</span> <span class="token class-name">V</span> <span class="token function">report</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> x <span class="token operator">=</span> outcome<span class="token punctuation">;</span>
    <span class="token comment">// 如果任务正常执行，那就返回任务执行的结果，也就是outcome</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> NORMAL<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">V</span><span class="token punctuation">)</span>x<span class="token punctuation">;</span>
    <span class="token comment">// 如果任务的状态大于CANCELLED，说明被取消了，那就抛出一个CancellationException异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;=</span> CANCELLED，说明被取消了，那就抛出一个<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CancellationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 否则，任务的状态应该是EXCEPTIONAL，说明任务执行出现异常，那就抛出一个ExecutionException异常</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span><span class="token punctuation">)</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果timed==true，说明当前设置了超时时间，那就计算一下到什么时候等待会超时，得到deadline</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> timed <span class="token operator">?</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos <span class="token operator">:</span> <span class="token number">0L</span><span class="token punctuation">;</span>
    <span class="token comment">// 先声明一个等待node</span>
    <span class="token class-name">WaitNode</span> q <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 当前线程是否要入队的标识符</span>
    <span class="token keyword">boolean</span> queued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果当前线程被中断了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 那就从等待队列汇中移除这个线程</span>
            <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 然后抛出InterruptedException异常</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
	    <span class="token comment">// 再获取一下task的状态 </span>
        <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>
        <span class="token comment">// 如果s大于COMPLETING，说明任务执行结束了，那就没必要等待了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> COMPLETING<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 这里判断一下q是否初始化了，如果已经初始化了，那就把q的线程置空</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                q<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token comment">// 直接返回</span>
            <span class="token keyword">return</span> s<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> COMPLETING<span class="token punctuation">)</span> <span class="token comment">// cannot time out yet</span>
            <span class="token comment">// 如果s == COMPLETING，说明这个task可能要执行完成了，那就让当前线程yield一下，让出cpu，看看能不能让执行task的线程抢占到cpu，然后执行结束</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token comment">// 到这里，说明可能的确要准备等待了，那就把这个node初始化一下</span>
            q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WaitNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queued<span class="token punctuation">)</span>
            <span class="token comment">// 初始化的时候queued==false，所以一定有一次循环会进入这里，</span>
            <span class="token comment">// 这里其实就是把waiters串起来，刚进来的这个等待线程放到等待队列的头部，然后原子更新waiters</span>
            queued <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span>
                                                    q<span class="token punctuation">.</span>next <span class="token operator">=</span> waiters<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 如果当前线程是带有超时的等待，就先判断下是不是到超时时间了</span>
            nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果超时了，把当前线程出队，然后返回。</span>
                <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> state<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 否则，就调用超时park进入等待</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
            <span class="token comment">// 再否则，就调用park进入无限等待，直到被唤醒</span>
            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 从等待队列waiters中清除当前节点</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeWaiter</span><span class="token punctuation">(</span><span class="token class-name">WaitNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果node不为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 先释放掉node持有的线程引用</span>
        node<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        retry<span class="token operator">:</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">// restart on removeWaiter race</span>
            <span class="token comment">// 如果waiters不等于空，进入for循环</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">WaitNode</span> pred <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> q <span class="token operator">=</span> waiters<span class="token punctuation">,</span> s<span class="token punctuation">;</span> q <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> q <span class="token operator">=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 先保存下当前node的下一个node</span>
                s <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                
                <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    pred <span class="token operator">=</span> q<span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    pred<span class="token punctuation">.</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>thread <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// check for race</span>
                        <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span>
                                                        q<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至此，最基础的ExecuteService的实现，就学习完了。</p> <p>其实，平常开发中，最常用到的也就是ThreadPoolExecutor这个线程池，分析完上面的内容，我们也可以对线程池有一个大概的了解了。</p> <p>除此之外，jdk还提供了定时线程池，可用于提交一个延迟执行的任务或者定时执行的任务。</p> <h3 id="scheduledexecutorservice"><a href="#scheduledexecutorservice" class="header-anchor">#</a> ScheduledExecutorService</h3> <p>ScheduledExecutorService也继承了ExecutorService接口，并在它的基础上又扩充了一些方法，下面简单看下源码。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 提交一个runnable任务到线程池，并且在单位为unit的delay时间后，执行该任务</span>
<span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span>
                                       <span class="token keyword">long</span> delay<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 提交一个callable任务到线程池，并且在单位为unit的delay时间后，执行该任务</span>
<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> callable<span class="token punctuation">,</span>
                                           <span class="token keyword">long</span> delay<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 提交一个runnable任务到线程池，在initialDelay时间后执行第一次，此后每隔period时间，都会执行一次，一旦任务执行出现异常，就会停止，并抛出该异常</span>
<span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">,</span>
                                                  <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span>
                                                  <span class="token keyword">long</span> period<span class="token punctuation">,</span>
                                                  <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 提交一个runnable任务到线程池，在initialDelay时间后执行第一次，执行完成之后，等待delay时间，然后再执行第二次，一旦任务执行出现异常，就会停止，并抛出该异常</span>
<span class="token keyword">public</span> <span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> comand<span class="token punctuation">,</span>
                                                     <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span>
                                                     <span class="token keyword">long</span> delay<span class="token punctuation">,</span>
                                                     <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="scheduledthreadpoolexecutor"><a href="#scheduledthreadpoolexecutor" class="header-anchor">#</a> ScheduledThreadPoolExecutor</h3> <p>ScheduledThreadPoolExecutor是ScheduledExecutorService的实现类，同时它也继承了ThreadPoolExecutor类，这说明，ScheduledThreadPoolExecutor应该是复用了一些ThreadPoolExecutor中的方法，下面就看下ScheduledThreadPoolExecutor的源码。</p> <p><strong>coming soon.</strong></p> <h3 id="forkjoinpool"><a href="#forkjoinpool" class="header-anchor">#</a> ForkJoinPool</h3> <p>ForkJoinPool是在jdk 1.7引入的新的线程池，它采用了分而治之的思想，将一个大的任务拆成多个小任务，让我们可以获得并行执行的能力。</p> <p><strong>coming soon.</strong></p> <h3 id="executors"><a href="#executors" class="header-anchor">#</a> Executors</h3> <p>最后，简单看下线程池工厂类，Executors中提供了5种创建线程池的方法，</p> <p>但是一般不建议直接使用工厂类生成的ExecutorService，而是建议通过调用ThreadPoolExecutor的构造方法，手动创建线程池。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 创建一个固定大小的线程池，使用无界队列</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>
                                    <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>
                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 创建一个只有一个worker线程的的线程池，使用无界队列</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>
        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>
                                <span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>
                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 创建一个核心线程为0，最大线程为Integer.MAX_VALUE的线程池，使用同步队列，每次来一个任务都会初始化一个线程</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>
                                    <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>
                                    <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 创建一个核心线程为corePoolSize，最大线程为Integer.MAX_VALUE的定时线程池，使用延迟队列</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ScheduledExecutorService</span> <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 1.8新增的线程池，ForkJoinPool</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newWorkStealingPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> parallelism<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span>
        <span class="token punctuation">(</span>parallelism<span class="token punctuation">,</span>
            <span class="token class-name">ForkJoinPool</span><span class="token punctuation">.</span>defaultForkJoinWorkerThreadFactory<span class="token punctuation">,</span>
            <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="扩展"><a href="#扩展" class="header-anchor">#</a> 扩展</h2> <h3 id="线程有几种状态"><a href="#线程有几种状态" class="header-anchor">#</a> 线程有几种状态</h3> <p><strong>六种状态</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
   * 新建状态，还未启动
   */</span>
  NEW<span class="token punctuation">,</span>
  <span class="token comment">/**
   * 运行状态，可能正在执行，但也有可能在等待一些其他系统资源，比如处理器资源
   */</span>
  RUNNABLE<span class="token punctuation">,</span>
  <span class="token comment">/**
   * 阻塞状态，等待监视器锁，在sync修饰的同步代码块或方法外阻塞，等待进入代码块
   */</span>
  BLOCKED<span class="token punctuation">,</span>
  <span class="token comment">/**
   * 等待状态，一般调用了以下方法后会进入此状态
   * 1. Object#wait() 
   * 2. Thread#join()
   * 3. LockSupport#park
   * wait和join都需要被notify或notifyAll唤醒，park需要被unpark唤醒
   */</span>
  WAITING<span class="token punctuation">,</span>
  <span class="token comment">/**
   * 超时等待状态，一般调用了以下方法后会进入此状态
   * 1. Thread.sleep()
   * 2. Object#wait(long) 
   * 3. Thread#join(long)
   * 4. LockSupport#parkNanos(long)
   * 5. LockSupport#parkUntil(long)
   */</span>
  TIMED_WAITING<span class="token punctuation">,</span>
  <span class="token comment">/**
   * 终止状态，线程执行完之后，会进入此状态
   */</span>
  TERMINATED<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/itForeverYoung/blog/edit/master/docs/java/thread-pool-executor.md" target="_blank" rel="noopener noreferrer">在GitHub上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">8/18/2020, 5:31:53 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/java/Semaphore.html" class="prev">
        Semaphore
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.54d83c99.js" defer></script><script src="/assets/js/2.686cfa6a.js" defer></script><script src="/assets/js/67.5ab34c14.js" defer></script>
  </body>
</html>
