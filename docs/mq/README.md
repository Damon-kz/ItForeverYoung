# 消息中间件专题

## 为什么需要MQ

### 优点

1. 解耦
2. 异步
3. 削峰

### 缺点

1. 系统可用性降低
2. 系统复杂性升高
3. 数据一致性问题

## 三种主流MQ对比

| 特性           | Rabbit MQ                                                    | Rocket MQ                                                    | Kafka                                                        |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 支持的协议     | AMQP                                                         | 自定义协议                                                   | 基于TCP的自定义协议                                          |
| 消息存储方式   | 内存, 磁盘, 支持少量堆积                                     | 磁盘, 支持大量堆积                                           | 内存, 磁盘, 支持大量堆积                                     |
| 消息消费方式   | 推模式                                                       | 拉模式<br />(PushConsumer也是通过拉模式实现的)               | 拉模式                                                       |
| 重复消息       | at least once<br />at most once                              | at least once<br />at most once                              | at least once                                                |
| 顺序消息       | 不支持.                                                      | 支持.<br />全局顺序消息, 性能较差.<br />分区顺序消息, 性能较好. | 支持.<br />全局顺序消息, 性能较差.<br />分区顺序消息, 性能较好. |
| 定时消息       |                                                              | 简单支持, 只支持18个固定的延时等级.                          |                                                              |
| 事务消息       | 不支持.                                                      | 简单支持, <br />即只能保证本地事务和消息投递成功/失败的事务, <br />如果consumer端事务执行失败, 只能进行事务补偿操作. | 不支持.                                                      |
| 回溯消息       | 不支持.                                                      | 支持根据时间点的回溯.                                        | 支持根据offset的回溯.                                        |
| 消息确认       | 支持.<br />producer,<br />消息投递到目标队列后,返回成功.<br />consumer,<br />可通过设置autoAck=false来开启显式确认. | 支持.                                                        | 支持.                                                        |
| 消息重试       |                                                              |                                                              |                                                              |
| 吞吐量         |                                                              |                                                              |                                                              |
| 并发度         |                                                              |                                                              |                                                              |
| 可靠性         |                                                              |                                                              |                                                              |
| 时效性         |                                                              |                                                              |                                                              |
| 持久性         |                                                              |                                                              |                                                              |
| 单机TPS        |                                                              |                                                              |                                                              |
| 开发语言       | Erlang                                                       | Java                                                         | Scala                                                        |
| 负载均衡       |                                                              |                                                              |                                                              |
| 集群方式       | 简单集群, <br />支持镜像队列.                                | nameServer可集群部署, 不同节点之间无通信,<br />broker支持master-slave的一对多集群部署. | leader-slave的无状态集群,<br />依赖zookeeper.                |
| 客户端支持语言 |                                                              |                                                              |                                                              |

## 一些基础概念

### Producer

消息生产者.

### Consumer

消息消费者.

## 消息消费模式

### 推模式

消息由broker主动推送给consumer.

#### 优点

1. 实时性高, broker一有消息就可以主动推送给消费者,
2. 消费者实现简单, 只需要等待消息到达即可.

#### 缺点

1. broker消息推送的速率和consumer消费的速率难以平衡,
   1. 因为broker有消息就会主动推送, 那如果突然有大批量的消息过来, 全部推送给consumer, 那consumer可能消费不过来, 就会引发问题,
   2. consumer的宿主机的性能不一致, 那有的消费者消费速度快, 有的消费者消费速度慢, 但是broker并不知道哪个consumer性能好, 所以就没有办法平衡不同的consumer的推送速率,
   3. 当然, 上述的问题, 可以通过添加额外逻辑去判断, 比如说, consumer可以选择拒绝消费本次推送过来的消息, 这样broker再去轮询(假设是轮询方式)下一个consumer节点进行推送, 再复杂点, broker可以再维护一份consumer消费状态, 但是, 这样带来的问题就是broker实现起来会很复杂.
2. 消息的批量处理实现起来比较复杂, 一般来说, 推模式应该是来一条消息就把这个消息推送给consumer, 如果要实现批量推送, 有两种方式, 
   1. 在broker端进行配置, 每次缓存N条消息后再推送给consumer, 但是, 这样带来的问题是, broker并不知道consumer的消费能力是多少, 一旦批量推送的消息超过consumer的消费能力, 可能会被拒绝,
   2. 在consumer端进行配置, 当一个新的consumer加入进来后, 先根据设置将自己的最大消费能力告知broker, 然后, 在broker端维护一份consumer的消费能力, 但是, 这样处理的问题是, broker实现起来会比较复杂.
3. broker的工作量比较大, 就影响了broker服务器的性能.

所以说, 推模式适用于消息量不大, 消费能力强, 但是对实时性要求特别高的情况.

### 拉模式

消息由consumer主动到broker拉取.

#### 优点

1. consumer可以根据自己的消费能力, 定时发起拉取请求, 甚至可以当发现消费不过来的时候, 暂停拉取消息,
2. broker的实现简单, 只需要保存消息即可, 有consumer的拉取请求, 就给它消息,
3. 相对于推模式来说, 拉模式更容易实现消息的批量处理, consumer可以根据自己的消费能力, 一次性拉取多条消息.

#### 缺点

1. 消息延迟, 也就是实时性相对于推模式, 比较差, 既然是consumer主动拉取, 那consumer如何知道来新消息了呢, 那它只能不停地去轮询, 轮询间隔设定的过短, 就会导致有很多无用请求, 设定的过长, 就会导致消息拉取的实时性比较差,
2. 忙请求, 其实和1有些类似, 就是说, 即便是在一段时间内没有任何消息到达, consumer还是必须定时去请求broker拉取数据, 但是又没有数据到达, 所以就是忙请求了.

### 二者对比

推模式和拉模式, 都各自有优缺点, 那应该如何选择呢, 我们看一下主流的消息中间件是如何选择的.

| MQ        | 推模式 | 拉模式 |
| --------- | ------ | ------ |
| Rocket MQ | ❌      | ✅      |
| Kafka     | ❌      | ✅      |
| Rabbit MQ | ✅      | ❌      |

**注: 简单提一句, Rocket MQ在提供的Java API中虽然同时支持Push和Pull, 但是它的Push也是通过Pull来实现的, 所以这里我们还是将其视为只支持拉模式.**

