(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{436:function(v,_,a){v.exports=a.p+"assets/img/java.688aa2ec.jpg"},587:function(v,_,a){"use strict";a.r(_);var i=a(6),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,i=v._self._c||_;return i("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[i("h1",{attrs:{id:"java-篇"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#java-篇"}},[v._v("#")]),v._v(" Java 篇")]),v._v(" "),i("p",[v._v("首先，看一下Java的知识图谱。")]),v._v(" "),i("p",[i("img",{attrs:{src:a(436),alt:"java"}})]),v._v(" "),i("h2",{attrs:{id:"面试问题连环炮"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#面试问题连环炮"}},[v._v("#")]),v._v(" 面试问题连环炮")]),v._v(" "),i("h3",{attrs:{id:"基础"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[v._v("#")]),v._v(" 基础")]),v._v(" "),i("ol",[i("li",[v._v("Object有哪些方法？\n"),i("ol",[i("li",[v._v("native 方法有：getClass()、hashCode()、clone()、notify()、notifyAll()、wait(long)")]),v._v(" "),i("li",[v._v("Java 方法有：equals()、toString()、wait()、wait(long, int)、finalize()")])])]),v._v(" "),i("li",[v._v("java 中操作字符串都有哪些类？它们之间有什么区别？")]),v._v(" "),i("li",[v._v('String str="i"与 String str=new String("i")一样吗？')]),v._v(" "),i("li",[v._v("如何将字符串反转？")]),v._v(" "),i("li",[v._v("== 和 equals 的区别是什么？")]),v._v(" "),i("li",[v._v("为什么重写 equals() 方法就必须重写 hashCode() 方法？")]),v._v(" "),i("li",[v._v("两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？")]),v._v(" "),i("li",[v._v("final 在 java 中有什么作用？ static 呢？")]),v._v(" "),i("li",[v._v("final、finally 和 finalize 的区别？")]),v._v(" "),i("li",[v._v("能不能讲一下 int 的拆箱和装箱？")]),v._v(" "),i("li",[v._v("抽象类和接口有什么区别？")]),v._v(" "),i("li",[v._v("普通类和抽象类有哪些区别？")]),v._v(" "),i("li",[v._v("抽象类一定要有抽象方法吗？")]),v._v(" "),i("li",[v._v("抽象类能使用 final 修饰吗？")]),v._v(" "),i("li",[v._v("java 中 IO 流分为几种？为什么有了字节流还要有字符流？\n"),i("ol",[i("li",[v._v("字节流和字符流")]),v._v(" "),i("li",[v._v("输入流和输出流")])])]),v._v(" "),i("li",[v._v("代理了解吗？什么是静态代理？什么是动态代理？动态代理有几种实现方式？")])]),v._v(" "),i("h3",{attrs:{id:"集合"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#集合"}},[v._v("#")]),v._v(" 集合")]),v._v(" "),i("ol",[i("li",[v._v("Java中有哪些集合？")]),v._v(" "),i("li",[v._v("Collection 和 Collections 有什么区别？")]),v._v(" "),i("li",[v._v("List、Set、Map 之间的区别是什么？")]),v._v(" "),i("li",[v._v("HashMap 和 Hashtable 有什么区别？")]),v._v(" "),i("li",[v._v("如何决定使用 HashMap 还是 TreeMap？")]),v._v(" "),i("li",[v._v("Java 中的 TreeMap 是采用什么树实现的？")]),v._v(" "),i("li",[v._v("说一下 HashMap 的实现原理？ 扩容机制了解吗？为什么说它不是线程安全的？如果要线程安全应该用什么？")]),v._v(" "),i("li",[v._v("说一下 ConcurrentHashMap 的实现原理？")]),v._v(" "),i("li",[v._v("说一下 HashSet 的实现原理？它和 HashMap 有什么区别？它是如何检查重复的？")]),v._v(" "),i("li",[v._v("ArrayList 和 LinkedList 的区别是什么？")]),v._v(" "),i("li",[v._v("ArrayList 和 Vector 的区别是什么？")]),v._v(" "),i("li",[v._v("Array 和 ArrayList 有何区别？")]),v._v(" "),i("li",[v._v("如何实现数组和 List 之间的转换？")]),v._v(" "),i("li",[v._v("在 Queue 中 poll() 和 remove() 有什么区别？")]),v._v(" "),i("li",[v._v("哪些集合类是线程安全的？")]),v._v(" "),i("li",[v._v("迭代器 Iterator 是什么？怎么使用？有什么特点？")]),v._v(" "),i("li",[v._v("Iterator 和 ListIterator 有什么区别？")]),v._v(" "),i("li",[v._v("Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？")])]),v._v(" "),i("h3",{attrs:{id:"多线程"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[v._v("#")]),v._v(" 多线程")]),v._v(" "),i("ol",[i("li",[v._v("用过线程池吗？为什么要用线程池？几个参数是怎么设置的？拒绝策略是什么？为什么不建议使用Executors工厂类？")]),v._v(" "),i("li",[v._v("线程有几种状态？")]),v._v(" "),i("li",[v._v("Runnable 和 Callable 的区别？")]),v._v(" "),i("li",[v._v("FutureTask 是什么？")]),v._v(" "),i("li",[v._v("Thread 的 run() 和 start() 方法有什么区别？")]),v._v(" "),i("li",[v._v("为什么我们 start() 方法时会执行 run() 方法？为什么不能直接调用 run() 方法？")]),v._v(" "),i("li",[i("RouterLink",{attrs:{to:"/java/thread-local.html"}},[v._v("ThreadLocal")]),v._v(" 有用过吗？他是如何实现同一个线程共享变量的？子线程能拿到父线程设置的值吗？如果我想拿到该怎么做？")],1),v._v(" "),i("li",[v._v("Java中有哪几种锁？\n"),i("ol",[i("li",[v._v("synchronized中有偏向锁、轻量级锁、重量级锁，同时它也是一个可重入锁；")]),v._v(" "),i("li",[v._v("ReentrantLock可重入锁；")]),v._v(" "),i("li",[v._v("ReentrantReadWriteLock读写锁；")]),v._v(" "),i("li",[v._v("ReentrantLock和ReentrantReadWriteLock默认都是非公平锁，可通过构造方法初始化公平锁；")]),v._v(" "),i("li",[v._v("Condition条件锁，目前可使用的只有AbstractQueuedSynchronizer.ConditionObject这一个实现；")]),v._v(" "),i("li",[v._v("自旋锁，自旋锁只是一个概念，它不是一个具体的类或者接口，ReentrantLock和ReentrantReadWriteLock中都有自旋锁的代码实现；")])])]),v._v(" "),i("li",[v._v("说一下 "),i("RouterLink",{attrs:{to:"/java/ReentrantLock.html"}},[v._v("ReentrantLock")]),v._v(" 的实现原理")],1),v._v(" "),i("li",[v._v("说一下 "),i("RouterLink",{attrs:{to:"/java/ReentrantReadWriteLock.html"}},[v._v("ReentrantReadWriteLock")]),v._v(" 的实现原理")],1),v._v(" "),i("li",[i("RouterLink",{attrs:{to:"/java/Semaphore.html"}},[v._v("Semaphore")]),v._v(" 有用过吗？用在什么场景？它的底层原理是什么？\n"),i("ol",[i("li",[v._v("可用在限流操作上，例如令牌桶算法。")])])],1),v._v(" "),i("li",[i("RouterLink",{attrs:{to:"/java/CyclicBarrier.html"}},[v._v("CyclicBarrier")]),v._v(" 和 "),i("RouterLink",{attrs:{to:"/java/CountdownLatch.html"}},[v._v("CountdownLatch")]),v._v(" 有什么区别？\n"),i("ol",[i("li",[v._v("CountDownLatch只能使用一次；CyclicBarrier可以循环使用；")]),v._v(" "),i("li",[v._v("CountDownLatch的含义是，所有线程都会等待某一个或几个条件满足后，才能执行；")]),v._v(" "),i("li",[v._v("CyclicBarrier的含义是，前几个线程必须要等待最后一个线程到了之后，才能执行；")]),v._v(" "),i("li",[v._v("CountDownLatch是通过内部继承了AQS类的Sync类来实现的，其实现逻辑是：\n"),i("ol",[i("li",[v._v("初始化count参数，实际上就是初始化count重锁，也就是把count赋值给AQS的同步属性state；")]),v._v(" "),i("li",[v._v("await()方法实际上是调用了AQS类的加锁方法，当state != 0时，永远返回加锁失败，这样所有线程就会进入等待队列等待；")]),v._v(" "),i("li",[v._v("countDown()方法每调用一次，就会释放一重锁；")]),v._v(" "),i("li",[v._v("当state == 0时，变成无锁状态，等待队列中的线程就会被唤醒，开始执行。")])])]),v._v(" "),i("li",[v._v("CyclicBarrier内部维护了一个ReentrantLock的lock对象和一个Condition的trip对象，其实现逻辑是：\n"),i("ol",[i("li",[v._v("初始化的parties参数，指定每次屏障执行需要几个参与者；")]),v._v(" "),i("li",[v._v("初始化的barrierAction参数，可指定一个Runnable对象，该任务会在屏障执行时首先调用；")]),v._v(" "),i("li",[v._v("await()方法会先调用lock加锁，然后判断当前已经有几个参与者在等待，\n"),i("ol",[i("li",[v._v("如果发现参与者还不够，就调用Condition的await()方法让线程进入条件队列等待；")]),v._v(" "),i("li",[v._v("如果发现参与者已经够了，就调用Condition的signalAll()方法唤醒所有线程，让其执行。")])])])])])])],1),v._v(" "),i("li",[v._v("synchronized 了解吗？在方法上、代码块内、静态变量上加 synchronized 有什么区别？底层是怎么实现的？jdk 1.6之后做了哪些锁优化？")]),v._v(" "),i("li",[v._v("synchronized 和 Lock 有什么区别？Lock 接口相比于 synchronized，优势是什么？")]),v._v(" "),i("li",[v._v("使用 synchronized 如何实现单缓冲区的生产者消费者模型？")]),v._v(" "),i("li",[v._v("volatile 了解吗？它线程安全吗？为什么不安全？为什么不能保证原子性？它是如何保证可见性、有序性的？")]),v._v(" "),i("li",[v._v("什么是CAS？什么是ABA问题？")]),v._v(" "),i("li",[v._v("什么是原子操作，Java中的原子操作是什么？")]),v._v(" "),i("li",[v._v("Java中如何阻塞一个线程？")]),v._v(" "),i("li",[v._v("Java中如何唤醒一个阻塞的线程？")]),v._v(" "),i("li",[v._v("在java中 wait() 和 sleep() 方法的不同？")]),v._v(" "),i("li",[v._v("为什么 wait() 方法和 notify()/notifyAll() 方法要在同步块中被调用？")]),v._v(" "),i("li",[v._v("现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？")]),v._v(" "),i("li",[v._v("用Java实现一个阻塞队列？")]),v._v(" "),i("li",[v._v("你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？")]),v._v(" "),i("li",[v._v("为什么会发生死锁，你能制造一个死锁吗？")]),v._v(" "),i("li",[v._v("什么是竞争条件？你怎样发现和解决竞争？")]),v._v(" "),i("li",[v._v("什么是不可变对象，它对写并发应用有什么帮助？")]),v._v(" "),i("li",[v._v("你在多线程环境中遇到的问题是什么？你是怎么解决它的？")])]),v._v(" "),i("h3",{attrs:{id:"其他"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[v._v("#")]),v._v(" 其他")]),v._v(" "),i("ol",[i("li",[v._v("线程与进程的区别？")]),v._v(" "),i("li",[v._v("你了解守护线程吗？它和非守护线程有什么区别？")]),v._v(" "),i("li",[v._v("什么是多线程中的上下文切换？")]),v._v(" "),i("li",[v._v("死锁与活锁的区别，死锁与饥饿的区别？")]),v._v(" "),i("li",[v._v("在Java中什么是线程调度？")]),v._v(" "),i("li",[v._v("Java中用到的线程调度算法是什么？\n"),i("ol",[i("li",[v._v("抢占式调度策略")]),v._v(" "),i("li",[v._v("时间片轮转调度算法")])])]),v._v(" "),i("li",[v._v("在线程中你怎么处理不可捕捉异常？")]),v._v(" "),i("li",[v._v("jdk 8的新特性有哪些？")]),v._v(" "),i("li",[v._v("jdk 14的新特性有哪些？")])])])}),[],!1,null,null,null);_.default=t.exports}}]);